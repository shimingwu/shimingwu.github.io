<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shiming&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="寄言燕雀莫相啅， 自有云霄万里高。">
<meta property="og:type" content="website">
<meta property="og:title" content="Shiming&#39;s Blog">
<meta property="og:url" content="https://shimingwu.github.io/index.html">
<meta property="og:site_name" content="Shiming&#39;s Blog">
<meta property="og:description" content="寄言燕雀莫相啅， 自有云霄万里高。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shiming Wu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shiming&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shiming&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shimingwu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Distributed-Database-System-9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/26/Distributed-Database-System-9/" class="article-date">
  <time datetime="2020-11-26T19:53:43.000Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/26/Distributed-Database-System-9/">Distributed Database System (9)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Query-Processing"><a href="#Query-Processing" class="headerlink" title="Query Processing"></a>Query Processing</h2><p>Translates query into a query plan that minimizes some cost function</p>
<ul>
<li>Minimize total cost<ul>
<li>CPU cost, I/O cost, &amp; communication cost</li>
</ul>
</li>
<li>Minimize response time<ul>
<li>Time elapsed for query execution</li>
</ul>
</li>
</ul>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><ol>
<li>Query rewriting<ul>
<li>Query decomposition</li>
<li>Data localization</li>
</ul>
</li>
<li>Global query optimization<ul>
<li>Finds an optimal execution plan for query</li>
</ul>
</li>
<li>Distributed query execution<ul>
<li>Executes query plan to compute query result</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/26/Distributed-Database-System-9/" data-id="cki7gopfc001hzprv3p20h0g0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/26/Distributed-Database-System-8/" class="article-date">
  <time datetime="2020-11-26T17:48:28.000Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/26/Distributed-Database-System-8/">Distributed Database System (8)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Consistency-Levels"><a href="#Consistency-Levels" class="headerlink" title="Consistency Levels"></a>Consistency Levels</h2><ul>
<li>Strong Consistency<ul>
<li>See all previous writes</li>
</ul>
</li>
<li>Eventual Consistency<ul>
<li>See subset of previous writes</li>
</ul>
</li>
<li>Consistent Prefix<ul>
<li>See initial sequence of writes</li>
</ul>
</li>
<li>Bounded Staleness<ul>
<li>See all “old” writes</li>
</ul>
</li>
<li>Monotonic Reads<ul>
<li>See increasing subset of writes</li>
</ul>
</li>
<li>Read My Writes<ul>
<li>See all writes performed by reader</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/26/Distributed-Database-System-8/" data-id="cki7gopfa001ezprv3rjx398k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/26/Distributed-Database-System-7/" class="article-date">
  <time datetime="2020-11-26T16:21:47.000Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/26/Distributed-Database-System-7/">Distributed Database System (7)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Raft-Consensus-Algorithm"><a href="#Raft-Consensus-Algorithm" class="headerlink" title="Raft Consensus Algorithm"></a>Raft Consensus Algorithm</h2><h3 id="Server-States"><a href="#Server-States" class="headerlink" title="Server States:"></a>Server States:</h3><ul>
<li>Follower<ul>
<li>Passive but expects regular heartbeats from leader</li>
</ul>
</li>
<li>Candidate<ul>
<li>Issues RequestVote RPCs to get elected as leader</li>
</ul>
</li>
<li>Leader<ul>
<li>handles client interactions &amp; issues AppendEntries RPCs<ul>
<li>Replicate its log</li>
<li>Sends heartbeats to maintain leadership</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h2><p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h2 id="Remote-Procedure-Calls-RPCs"><a href="#Remote-Procedure-Calls-RPCs" class="headerlink" title="Remote Procedure Calls (RPCs)"></a>Remote Procedure Calls (RPCs)</h2><ul>
<li>RequestVote RPC<ul>
<li>Candidate发送RequestVote RPC去请求成为leader</li>
</ul>
</li>
<li>AppendEntries RPC<ul>
<li>Leader用AppendEntries RPC发送log和heartbeat</li>
</ul>
</li>
</ul>
<h2 id="Log完整度"><a href="#Log完整度" class="headerlink" title="Log完整度"></a>Log完整度</h2><p>X的log比Y的log更完整的情况只有：</p>
<ol>
<li>X的log中的最后一个term比Y的log中的最后一个term大</li>
<li>term相同，但是X的最后一个index更大。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/26/Distributed-Database-System-7/" data-id="cki7gopf9001czprvbi4b3uda" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/26/Distributed-Database-System-6/" class="article-date">
  <time datetime="2020-11-26T12:42:58.000Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/26/Distributed-Database-System-6/">Distributed Database System (6)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="One-Copy-Database"><a href="#One-Copy-Database" class="headerlink" title="One-Copy Database"></a>One-Copy Database</h2><ul>
<li>One-copy serializable (1SR)</li>
<li>Mutual Consistency<ul>
<li>Strong mutual consistency</li>
<li>Weak mutual consistency</li>
</ul>
</li>
</ul>
<h2 id="Replicas-Update"><a href="#Replicas-Update" class="headerlink" title="Replicas Update"></a>Replicas Update</h2><ul>
<li>DBMS-level replication<ul>
<li>Statement-based replication<br>直接发statement</li>
<li>Write-ahead log (WAL) shipping </li>
</ul>
</li>
<li>Application-level replication</li>
</ul>
<h2 id="Replication-Protocols"><a href="#Replication-Protocols" class="headerlink" title="Replication Protocols"></a>Replication Protocols</h2><img src="/2020/11/26/Distributed-Database-System-6/replication_protocols.png" class="" title="replication_protocols">

<h3 id="When-are-updates-propagated-to-copies"><a href="#When-are-updates-propagated-to-copies" class="headerlink" title="When are updates propagated to copies"></a>When are updates propagated to copies</h3><ul>
<li>Eager (Synchronous) update:<ul>
<li>Strong mutual consistency</li>
<li>Based on read-one-write-all (ROWA) protocols</li>
</ul>
</li>
<li>Lazy (Asynchronous) update:<ul>
<li>Need to ensure that updates are applied in the <strong>same order</strong> to all replicas</li>
</ul>
</li>
</ul>
<h3 id="Where-are-updates-allowed-to-occur"><a href="#Where-are-updates-allowed-to-occur" class="headerlink" title="Where are updates allowed to occur"></a>Where are updates allowed to occur</h3><ul>
<li>Centralized technique:<ul>
<li>Master copy updated first</li>
</ul>
</li>
<li>Distributed technique:<ul>
<li>Any site can update first</li>
</ul>
</li>
</ul>
<h3 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h3><ul>
<li>Eager Centralized Protocols<ul>
<li>Eager Single-Master Protocol: 有一个single master，同时也是lock manager。<ul>
<li>Read：由TC问一下master拿S-lock，从哪个site读都行</li>
<li>Write：由TC问一下master拿X-lock，master进行写操作，再保证其他site也进行写操作。</li>
</ul>
</li>
<li>Eager Primary Copy Protocol: master有着primary copy。更新不同的数据，master不一样。其他和single-master一样。</li>
</ul>
</li>
<li>Eager Distributed Protocols<ul>
<li>Read：先看看自己有没有数据备份，有的话，直接读，没有的话，则问别人</li>
<li>Write：先看看自己有没有数据备份，有的话，直接写，没有的话，则问别人</li>
</ul>
</li>
<li>Lazy Centralized Protocols<ul>
<li>Lazy Single Master: There is a single master site containing master copies of all objects</li>
<li>Refresh transaction</li>
<li>一个T被commit后，master告诉TC结束了，用同一个order对其他的site进行更新。更新使用refresh transaction的方式。</li>
</ul>
</li>
<li>Lazy Distributed Protocols</li>
</ul>
<blockquote>
<p>In lazy protocol, the execution is not necessary 1SR</p>
</blockquote>
<h2 id="Last-Writer-Wins-Heuristic"><a href="#Last-Writer-Wins-Heuristic" class="headerlink" title="Last-Writer-Wins Heuristic"></a>Last-Writer-Wins Heuristic</h2><p>为了避免写的冲突导致replicas的状态不一致，后发生的write会直接无视前一个write写的值直接执行覆盖。（blind write）</p>
<h2 id="Quorum-Consensus-QC-Protocol"><a href="#Quorum-Consensus-QC-Protocol" class="headerlink" title="Quorum Consensus (QC) Protocol"></a>Quorum Consensus (QC) Protocol</h2><ol>
<li><p>Tr (O) + Tw(O) &gt; Wt(O)</p>
</li>
<li><p>2 × Tw(O) &gt; Wt(O)</p>
</li>
<li><p>The sum of read and write threshold must exceed the total weights of all replicas. This helps to ensure any next subsequent read operation will read an updated value performed by write.</p>
</li>
<li><p>2 * Tw(O) &gt; Wt(O) : Prevent two concurrent write operations.</p>
</li>
</ol>
<h2 id="Handling-Failures"><a href="#Handling-Failures" class="headerlink" title="Handling Failures"></a>Handling Failures</h2><ul>
<li>Failure of Slave Sites<ul>
<li>Lazy replication<ul>
<li>Synchronize unavailable replicas later when they become available</li>
</ul>
</li>
<li>Eager replication<ul>
<li>ROWA (Read-One/Write-All)</li>
<li>ROWAA (Read-One/Write-All Available)<blockquote>
<p>Relaxation of ROWA protocol. Do not require updating of all replicas but only available replicas.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Failure of Master Site<ul>
<li>Elect a new master site<ul>
<li>选择想要的partition。如果多个partition且每个partition都有一个master，会产生数据不一致的问题。选择partition的算法：<ol>
<li>Simple algorithm</li>
<li>Majority consensus algorithm</li>
<li>Quorum consensus algorithm</li>
</ol>
</li>
<li>如果选择的partition没有可以工作的master，则选举新的master<ol>
<li>Consensus algorithm</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Simple-Algorithm"><a href="#Simple-Algorithm" class="headerlink" title="Simple Algorithm"></a>Simple Algorithm</h3><p>选择有可用master的partition。</p>
<h3 id="Majority-Consensus-Algorithm"><a href="#Majority-Consensus-Algorithm" class="headerlink" title="Majority Consensus Algorithm"></a>Majority Consensus Algorithm</h3><p>选择node数多的（大于一半数量）的partition。</p>
<h3 id="Quorum-Consensus-Algorithm"><a href="#Quorum-Consensus-Algorithm" class="headerlink" title="Quorum Consensus Algorithm"></a>Quorum Consensus Algorithm</h3><p>有权重。选择权重大的作为新的partition。</p>
<h2 id="CAP-Theorem"><a href="#CAP-Theorem" class="headerlink" title="CAP Theorem"></a>CAP Theorem</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li><p>Data Consistency</p>
</li>
<li><p>System Availability</p>
</li>
<li><p>Tolerance to Network Partitions</p>
</li>
<li><p>Forfeit consistency (丧失一致性)</p>
<ul>
<li>Resume execution on a selected partition</li>
<li>Data could become inconsistent if the selected partition requires a new master site</li>
</ul>
</li>
<li><p>Forfeit availability （丧失可用性）</p>
<ul>
<li>Wait for network to recover before resuming execution</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/26/Distributed-Database-System-6/" data-id="cki7gopf80019zprveysj965c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/22/Distributed-Database-System-5/" class="article-date">
  <time datetime="2020-11-22T16:44:23.000Z" itemprop="datePublished">2020-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/22/Distributed-Database-System-5/">Distributed Database System (5)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><ul>
<li>Single-partition transaction: a distributed transaction that access/update items from exactly one site</li>
<li>Multi-partition transaction: a distributed transaction that access/update items from more than one site </li>
</ul>
<h2 id="Schedules"><a href="#Schedules" class="headerlink" title="Schedules"></a>Schedules</h2><ul>
<li>Local schedule: transaction schedule at a local site</li>
<li>Global Schedule: <ul>
<li>Let T = {T1, · · · , Tn} be a set of global transactions executed over m sites with local schedules {S1, · · · , Sm}</li>
<li>A schedule S is a global schedule for T and {S1, · · · , Sm} if each Si is a subsequence of S</li>
</ul>
</li>
</ul>
<h2 id="Concurrency-Control-Protocols"><a href="#Concurrency-Control-Protocols" class="headerlink" title="Concurrency Control Protocols"></a>Concurrency Control Protocols</h2><ul>
<li>Lock-based protocols</li>
<li>Timestamp-based protocols</li>
<li>Optimistic protocols</li>
<li>Mutiversion protocols</li>
<li>Hybrid protocols</li>
</ul>
<h1 id="Distributed-Lock-based-Protocols"><a href="#Distributed-Lock-based-Protocols" class="headerlink" title="Distributed Lock-based Protocols"></a>Distributed Lock-based Protocols</h1><ul>
<li>Centralized 2PL (C2PL)<ul>
<li>1个site作为central site管理lock</li>
<li>Coordinating Site每次读 x 时，都和Central site说一声</li>
</ul>
</li>
<li>Distributed 2PL (D2PL)<ul>
<li>每个site上面都有一个lock manager，各自管理</li>
</ul>
</li>
</ul>
<h2 id="Two-Phase-Locking-2PL-Protocol"><a href="#Two-Phase-Locking-2PL-Protocol" class="headerlink" title="Two Phase Locking (2PL) Protocol"></a>Two Phase Locking (2PL) Protocol</h2><blockquote>
<p>2PL schedules are conflict serializable</p>
</blockquote>
<ul>
<li>Growing phase: before releasing 1st lock</li>
<li>Shrinking phase: after releasing 1st lock</li>
</ul>
<ol>
<li>To read an object O, a Xact must hold a S-lock or X-lock on O</li>
<li>To write to an object O, a Xact must hold a X-lock on O</li>
<li>Once a Xact releases a lock, the Xact can’t request any more<br>locks</li>
</ol>
<h2 id="Strict-Two-Phase-Locking-S2PL"><a href="#Strict-Two-Phase-Locking-S2PL" class="headerlink" title="Strict Two Phase Locking (S2PL)"></a>Strict Two Phase Locking (S2PL)</h2><blockquote>
<p>Strict 2PL schedules are conflict<br>serializable &amp; recoverable</p>
</blockquote>
<ol>
<li>To read an object O, a Xact must hold a S-lock or X-lock on O</li>
<li>To write to an object O, a Xact must hold a X-lock on O</li>
<li>A Xact must hold on to locks until Xact commits or aborts</li>
</ol>
<h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><ul>
<li>Waits-for graph (WFG)<ul>
<li>Deadlock is detected if WFG has a cycle</li>
</ul>
</li>
</ul>
<h2 id="Distributed-Deadlock-Detection"><a href="#Distributed-Deadlock-Detection" class="headerlink" title="Distributed Deadlock Detection"></a>Distributed Deadlock Detection</h2><ul>
<li>Centralized approach<ul>
<li>每一个site都有一个Local Wait-For Graph (LWFG)</li>
<li>阶段性地发给deadlock detector去检测。deadlock detector会将所有site的LWFG组合成Global Wait-For Graph (GWFG)并且检查是否有闭环。</li>
</ul>
</li>
<li>Distributed approaches</li>
</ul>
<h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><ul>
<li>Each Xact is assigned a unique start timestamp</li>
<li>Wait-die policy<ul>
<li>如果事务A晚于事务B开始，那么事务A等待另外一个事务释放对应资源的锁或者直接abort。</li>
</ul>
</li>
<li>Wound-wait policy<ul>
<li>如果事务A早于事务B开始，那么事务A等待，或者abort。这是一种抢占方案。</li>
</ul>
</li>
</ul>
<h1 id="Timestamp-based-protocols"><a href="#Timestamp-based-protocols" class="headerlink" title="Timestamp-based protocols"></a>Timestamp-based protocols</h1><ul>
<li>Centralized Snapshot Isolation (CSI)<ul>
<li>一个site作为Centralized Coordinator (CC)，负责管理所有start和commit的时间戳（timestamp）的分发</li>
<li>TC会从CC上获取需要的timestamp，但是不管是对Write还是Read，lock都由TC各自管理</li>
</ul>
</li>
<li>Distributed Snapshot Isolation (DSI)</li>
</ul>
<h2 id="Snapshot-Isolation-（SI）"><a href="#Snapshot-Isolation-（SI）" class="headerlink" title="Snapshot Isolation （SI）"></a>Snapshot Isolation （SI）</h2><ul>
<li>Write: 不同的transaction各自写各自的事务时，看谁的commit的时间更晚</li>
<li>Read：只读commit最晚的</li>
</ul>
<p>SI不一定是serializable。</p>
<h2 id="Multiversion-Concurrency-Control-MVCC"><a href="#Multiversion-Concurrency-Control-MVCC" class="headerlink" title="Multiversion Concurrency Control (MVCC)"></a>Multiversion Concurrency Control (MVCC)</h2><p>在MVCC之前，主要采用”two-phase locking”，但”two-phase locking”过程中需要对读写操作进行加锁，这会带来显著的性能问题。因此，”two-phase locking”在读写高并发场景中已被逐步摒弃。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/22/Distributed-Database-System-5/" data-id="cki7gopf70017zprvaka54iab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/22/Distributed-Database-System-4/" class="article-date">
  <time datetime="2020-11-22T12:40:10.000Z" itemprop="datePublished">2020-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/22/Distributed-Database-System-4/">Distributed Database System (4)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol>
<li>Atomicity: Either all or none of the actions in transactions happen (recovery manager)</li>
<li>Consistency: If each transaction is consistent and the DB starts consistent, it ends up consistent</li>
<li>Isolation: Execution of one transaction is isolated from other transactions (concurrency control manager)</li>
<li>Durability: If a transaction commits, its effects persist (recovery manager)</li>
</ol>
<h2 id="Recovery-Manager"><a href="#Recovery-Manager" class="headerlink" title="Recovery Manager"></a>Recovery Manager</h2><ul>
<li>Commit(T): installs T’s updated pages into stable database</li>
<li>Abort(T): restores all data that T updated to their prior values</li>
<li>Restart(T): recovers database to a consistent state from system<br>failure<ul>
<li>aborts all active Xacts at the time of system failure</li>
<li>installs updates of all committed Xacts that were not installed in the stable database before the failure</li>
</ul>
</li>
</ul>
<h3 id="Log-based-Database-Recovery"><a href="#Log-based-Database-Recovery" class="headerlink" title="Log-based Database Recovery"></a>Log-based Database Recovery</h3><ul>
<li><p>Commit</p>
<ul>
<li>Force-at-commit protocol</li>
</ul>
</li>
<li><p>Abort</p>
<ul>
<li>Write-ahead logging (WAL) protocol</li>
</ul>
<p>在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中</p>
</li>
<li><p>Restart</p>
<ul>
<li>Redo phase: scans log and keeps track of active Xacts</li>
<li>Undo phase: aborts all active Xacts</li>
</ul>
</li>
</ul>
<h2 id="Distributed-Transactions"><a href="#Distributed-Transactions" class="headerlink" title="Distributed Transactions"></a>Distributed Transactions</h2><ul>
<li>Transaction coordinator (TC)</li>
<li>Transaction manager (TM)</li>
</ul>
<br/>
<img src="/2020/11/22/Distributed-Database-System-4/TMTC.png" class="" title="TMTC">
<br/>

<h2 id="Failures-in-Distributed-DBMS"><a href="#Failures-in-Distributed-DBMS" class="headerlink" title="Failures in Distributed DBMS"></a>Failures in Distributed DBMS</h2><ul>
<li>Site failures<ul>
<li>Fail-stop model: A site is either working correctly (i.e.operational) or not working at all (i.e. failed)</li>
<li>Partial site failure: Some site(s) are operational &amp; some site(s) are down</li>
<li>Total site failure: All sites are down</li>
</ul>
</li>
<li>Communication failures<ul>
<li>Lost messages, network partitioning, etc.</li>
</ul>
</li>
</ul>
<h2 id="Two-Phase-Commit-2PC-Protocol"><a href="#Two-Phase-Commit-2PC-Protocol" class="headerlink" title="Two-Phase Commit (2PC) Protocol"></a>Two-Phase Commit (2PC) Protocol</h2><ul>
<li>Voting/Preparation Phase: coordinator从participants那儿收集votes</li>
<li>Decision Phase：coordinator会将global decision发送给所有的participants （只要有一个abort就全部abort）</li>
</ul>
<h2 id="Dealing-with-Site-Failures"><a href="#Dealing-with-Site-Failures" class="headerlink" title="Dealing with Site Failures"></a>Dealing with Site Failures</h2><h3 id="Recovery-Protocols-for-2PC"><a href="#Recovery-Protocols-for-2PC" class="headerlink" title="Recovery Protocols for 2PC"></a>Recovery Protocols for 2PC</h3><p><strong>Coordinator Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>直接resume INITIAL状态</li>
</ul>
</li>
<li>Fails in WAIT state： <ul>
<li>重新发送prepare消息</li>
</ul>
</li>
<li>Fails in COMMIT/ABORT state<ul>
<li>如果已经收到了所有的ACK消息，则不做任何事</li>
<li>否则，将之前的Global-commit/Global-abort的决定再次发送</li>
</ul>
</li>
</ul>
<p><strong>Participant Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>单方面abort</li>
</ul>
</li>
<li>Fails in READY state： <ul>
<li>如果一个participant进入了READY状态，这就证明它之前已经发送了vote-commit</li>
<li>重新发送vote-commit</li>
</ul>
</li>
<li>Fails in ABORT state：<ul>
<li>不做任何事</li>
</ul>
</li>
<li>Fails in COMMIT state：<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<h3 id="Termination-Protocols-for-2PC"><a href="#Termination-Protocols-for-2PC" class="headerlink" title="Termination Protocols for 2PC"></a>Termination Protocols for 2PC</h3><ul>
<li>Basic Termination Protocol</li>
<li>Cooperative Termination Protocol</li>
</ul>
<p><strong>Basic Termination Protocol</strong></p>
<ul>
<li><p>Cooordinator Timeouts</p>
<ul>
<li>Timeout in WAIT state<ul>
<li>等待所有participant的vote的时候超时了，则写入log并且发送Global-abort</li>
</ul>
</li>
<li>Timeout in COMMIT/ABORT state<ul>
<li>等待所有participant的ACK的时候超时了，则对没有回复的participant再次发送Global-commit/Global-abort</li>
</ul>
</li>
</ul>
</li>
<li><p>Participant Timeouts</p>
<ul>
<li><p>Timeout in INITIAL state</p>
<ul>
<li>等待prepare消息，可以单方面abort</li>
</ul>
</li>
<li><p>Timeout in READY state</p>
<ul>
<li><strong>必须等待coordinator的指令</strong></li>
</ul>
<blockquote>
<p>2PC算法可以正确处理其他participant的failure，因为coordinator可以发送适当的指令。但是当coordinator宕机时，它必须等到coordinator发送消息才可以继续执行commit/abort，所以被阻塞了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>Cooperative Termination Protocol</strong></p>
<p>为了防止刚刚阻塞的情况发生，Cooperative Termination Protocol决定允许participant与其他participants沟通来获取commit/abort情况。</p>
<ul>
<li><p>Participant Timeouts</p>
<ul>
<li><p>Timeout in READY state</p>
<ul>
<li>首先participant会有一个其他所有participants的地址列表</li>
<li>发送decision-request消息给所有其他participants<ul>
<li>对于其他收到decision-request的participant Q 而言</li>
<li>如果是INITIAL state，则回复”abort”</li>
<li>如果是READY，则回复”Uncertain”</li>
<li>如果是COMMIT/ABORT, 则回复决定</li>
</ul>
</li>
<li>收到任何决定（不管是Commit/abort）都执行</li>
<li>如果也有收到”Uncertain”，则把决定传给那些不知道的participant</li>
</ul>
<blockquote>
<p>这个protocol只能帮助减少阻塞，但不能完全解决。因为当所有人都在READY状态下，则大家还是必须等coordinator的指示。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Three-Phase-Commit-3PC-Protocol"><a href="#Three-Phase-Commit-3PC-Protocol" class="headerlink" title="Three-Phase Commit (3PC) Protocol"></a>Three-Phase Commit (3PC) Protocol</h2><ul>
<li>Voting/Preparation phase<ul>
<li>Coordinator collects votes from participants</li>
</ul>
</li>
<li>Dissemination (传播) phase<ul>
<li>Coordinator disseminates voting outcome to participants if there is no abort vote</li>
</ul>
</li>
<li>Decision phase<ul>
<li>Coordinator sends global decision to participants</li>
</ul>
</li>
</ul>
<h3 id="Recovery-Protocols-for-3PC"><a href="#Recovery-Protocols-for-3PC" class="headerlink" title="Recovery Protocols for 3PC"></a>Recovery Protocols for 3PC</h3><p><strong>Coordinator Site Failures</strong></p>
<ul>
<li>Fails in INITIAL/PRECOMMIT state： <ul>
<li>和participant询问</li>
</ul>
</li>
<li>Fails in COMMIT/ABORT state<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<p><strong>Participant Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>单方面abort</li>
</ul>
</li>
<li>Fails in READY/PRECOMMIT state： <ul>
<li>和participant询问</li>
</ul>
</li>
<li>Fails in ABORT/COMMIT state：<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<h3 id="Termination-Protocols-for-3PC"><a href="#Termination-Protocols-for-3PC" class="headerlink" title="Termination Protocols for 3PC"></a>Termination Protocols for 3PC</h3><ul>
<li><p>Cooordinator Timeouts</p>
<ul>
<li>Timeout in WAIT state<ul>
<li>等待所有participant的vote的时候超时了，则写入log并且发送Global-abort</li>
</ul>
</li>
<li>Timeout in PRECOMMIT state<ul>
<li>PRECOMMIT代表了所有的participant都vote for commit</li>
<li>对没有回复的participant再次发送prepare-to-commit消息</li>
<li>对其他有回复的participant发送Global-commit消息</li>
</ul>
</li>
<li>Timeout in COMMIT state<ul>
<li>Coordinator在等ACK</li>
<li>因为已知能进入COMMIT状态代表了所有的participants都在PRECOMMIT/COMMIT，所以对其他没有回复的participant发送Global-commit消息</li>
</ul>
</li>
<li>Timeout in ABORT state<ul>
<li>Coordinator在等ACK</li>
<li>因为已知能进入ABORT状态代表了所有的participants都在READY/ABORT，所以对其他没有回复的participant发送Global-abort消息</li>
</ul>
</li>
</ul>
</li>
<li><p>Participant Timeouts</p>
<ul>
<li>Timeout in INITIAL state<ul>
<li>可以单方面abort</li>
</ul>
</li>
<li>Timeout in READY state<ul>
<li>执行New Coordinator Termination Protocol</li>
</ul>
</li>
<li>Timeout in PRECOMMIT state<ul>
<li>执行New Coordinator Termination Protocol</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>New Coordinator Termination Protocol</strong></p>
<p>选取新的coordinator。</p>
<ul>
<li>Participant Timeouts<ul>
<li>Timeout in READY/PRECOMMIT state<ul>
<li>首先participant会有一个其他所有participants的地址列表</li>
<li>选举出来的新的coordinator会发送State-request message消息给所有其他participants<ul>
<li>如果有些participant是COMMIT state，则对所有人发送”global-commit”</li>
<li>否则，如果没有participant是PRECOMMIT state，则对所有人发送”global-abort”</li>
<li>如果上面两种情况都没有，则对所有人发送Prepare-to-commit，收到Prepare-to-commit的话就对其他的participants发送”global-commit”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/22/Distributed-Database-System-4/" data-id="cki7gopf60014zprvc0r42bm3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-3/" class="article-date">
  <time datetime="2020-11-21T21:09:22.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-3/">Distributed Database System (3)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="LSM-Storage"><a href="#LSM-Storage" class="headerlink" title="LSM Storage"></a>LSM Storage</h2><p>LSM storage for a relation R(K, V) consists of:</p>
<ul>
<li>A main-memory structure MemTable</li>
<li>A set of disk-based structures SSTables</li>
<li>A commit log file</li>
</ul>
<h3 id="MemTable-Memory-Table"><a href="#MemTable-Memory-Table" class="headerlink" title="MemTable (Memory Table)"></a>MemTable (Memory Table)</h3><ul>
<li>Contains the most recent updates organized in main-memory</li>
<li>MemTable is updated in-place<ul>
<li>Deleted records are not removed but marked with tombstones (denoted by ⊥)</li>
</ul>
</li>
<li>When size of MemTable reaches a certain threshold, the records in MemTable are sorted and flushed to disk as a new SSTable</li>
</ul>
<h3 id="SSTable-Sorted-String-Table"><a href="#SSTable-Sorted-String-Table" class="headerlink" title="SSTable (Sorted String Table)"></a>SSTable (Sorted String Table)</h3><ul>
<li>SSTables are immutable structures</li>
<li>SSTable records are <strong>sorted</strong> by relation’s key K</li>
<li>Each SSTable is associated with a range of key values &amp; a timestamp</li>
</ul>
<h3 id="Commit-Log-File"><a href="#Commit-Log-File" class="headerlink" title="Commit Log File"></a>Commit Log File</h3><ul>
<li>A commit log file is used to ensure durability</li>
<li>Each new update is appended to commit log &amp; updated to MemTable</li>
</ul>
<h2 id="Compaction-of-SSTables"><a href="#Compaction-of-SSTables" class="headerlink" title="Compaction of SSTables"></a>Compaction of SSTables</h2><p>Compaction helps to improve:</p>
<ul>
<li>Read performance by defragmenting table records</li>
<li>Improves space utilization by eliminating tombstones &amp; stale values</li>
</ul>
<h3 id="Compaction-Strategies"><a href="#Compaction-Strategies" class="headerlink" title="Compaction Strategies"></a>Compaction Strategies</h3><ul>
<li>Size-tiered Compaction Strategy (STCS)</li>
<li>Leveled Compaction Strategy (LCS)</li>
</ul>
<h2 id="Local-vs-Global-Indexing"><a href="#Local-vs-Global-Indexing" class="headerlink" title="Local vs Global Indexing"></a>Local vs Global Indexing</h2><p>Advantage of using local index: Update will be easier with local index. The index is associated with data stored in the same site.</p>
<p>Advantage of using global index, search will be easier. We only need to retrieve all the entries from one site.</p>
<h2 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h2><ul>
<li>B+-tree<ul>
<li>Updates are performed in-place </li>
<li>Posting list for each key is stored together</li>
<li>Example: MongoDB</li>
</ul>
</li>
<li>LSM Storage <ul>
<li>Updates are performed with append-only updates</li>
<li>Posting list for each key could be fragmented across multiple SSTables</li>
<li>Example: Cassandra</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-3/" data-id="cki7gopf40012zprvgemqhkbk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-2/" class="article-date">
  <time datetime="2020-11-21T20:18:24.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-2/">Distributed Database System (2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Distributed-Database-Design"><a href="#Distributed-Database-Design" class="headerlink" title="Distributed Database Design"></a>Distributed Database Design</h2><ul>
<li><code>Data fragmentation / partitioning</code>: how to<br>partition data into smaller pieces</li>
<li><code>Data allocation</code>: how to allocate data to various<br>sites</li>
<li><code>Data replication</code>: what data to replicate at each<br>site</li>
</ul>
<h2 id="Data-Fragmentation"><a href="#Data-Fragmentation" class="headerlink" title="Data Fragmentation"></a>Data Fragmentation</h2><p>There are three strategies used:</p>
<ul>
<li>Horizontal fragmentation (sharding)</li>
<li>Vertical fragmentation (Schema decomposition)</li>
<li>Hybrid fragmentation</li>
</ul>
<h3 id="Desirable-Properties-of-Fragmentation"><a href="#Desirable-Properties-of-Fragmentation" class="headerlink" title="Desirable Properties of Fragmentation"></a>Desirable Properties of Fragmentation</h3><ul>
<li>Completeness: <ul>
<li>在原R里面能找到的元素一定能在被碎片化后的R的set里面找到</li>
<li><code>∀t ∈ R, ∃ Ri such that t ∈ Ri</code> (<code>∀: for all</code>, <code>∃: there exists exactly one</code>, for all ts belongs to set R, there exists one Ri such that t will belong to.)</li>
</ul>
</li>
<li>Reconstruction：<ul>
<li>可以使用{R1, R2… Rn}还原R</li>
<li><code>R = R1 ∪ · · · ∪ Rn</code></li>
</ul>
</li>
<li>Disjointness: <ul>
<li>Horizontal Decomposition: 如果一个元素在R1里面找到，它就不会出现在其他Rx里面，即R1与其他任何R的交集都是空集</li>
<li>Vertical Decomposition：这个属性只用于non-primary key</li>
<li><code>∀ Ri ,Rj (i ！= j ⇒ Ri ∩ Rj = ∅)</code> </li>
</ul>
</li>
</ul>
<h2 id="Horizontal-fragmentation"><a href="#Horizontal-fragmentation" class="headerlink" title="Horizontal fragmentation"></a>Horizontal fragmentation</h2><h3 id="Techniques："><a href="#Techniques：" class="headerlink" title="Techniques："></a>Techniques：</h3><ul>
<li>Range Partitioning<ul>
<li>Partition R using predicates on some attributes<br>of R</li>
<li>R1 = σ A &lt; 100 (R) (Select all elements in R that is smaller than 100)</li>
<li>R2 = σ A &gt;= 100 (R) (Select all elements in R that is greater or equal than 100)</li>
</ul>
</li>
<li>Hash Partitioning<ul>
<li>Partition R into {R1, · · · ,Rn} based on hash function on some attribute of R (say R.A). 对某个attribute使用hash function来区分</li>
<li>Modulo method<ul>
<li>Problems: <ol>
<li>Uneven distribution</li>
<li>Difficult to add in new server, need to rehash all existing entries</li>
</ol>
</li>
</ul>
</li>
<li>Consistent Hashing<ul>
<li>Problems:<ol>
<li>Uneven distribution</li>
<li>Heterogeneity of servers’ performance</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Primary Horizontal fragmentation<ul>
<li>Fragmentation predicate Fi: Ri = σ Fi(R)</li>
<li>根据已知需要执行的query来进行range partition</li>
<li>Primary Horizontal fragmentation是一个加强版的range partition</li>
</ul>
</li>
<li>Derived Horizontal Fragmentation<ul>
<li>为了completeness, R.A ⊆ S.A</li>
<li>为了disjointness, S.A must be a key</li>
</ul>
</li>
</ul>
<h2 id="Vertical-fragmentation"><a href="#Vertical-fragmentation" class="headerlink" title="Vertical fragmentation"></a>Vertical fragmentation</h2><h3 id="Attribute-affinity-measure"><a href="#Attribute-affinity-measure" class="headerlink" title="Attribute affinity measure"></a>Attribute affinity measure</h3>

<p>Higher value means higher chance the 2 attributes will be queried together, therefore, we should group the attributes together.</p>
<h2 id="Hybrid-fragmentation"><a href="#Hybrid-fragmentation" class="headerlink" title="Hybrid fragmentation"></a>Hybrid fragmentation</h2><p>Combinations of horizontal/vertical fragmentation.</p>
<h2 id="Complete-Partitioning-wrt-Query"><a href="#Complete-Partitioning-wrt-Query" class="headerlink" title="Complete Partitioning wrt Query"></a>Complete Partitioning wrt Query</h2><p>假设F = {R1, R2, R3.. Rn}。<br>假设Q是在R上面执行的query。<br>执行了Q后，得到的Rx包含了所有的Q所需要的tuples，以及没有包含任何Q所不需要的tuples，那么F是R对于Q的complete partitioning。</p>
<h2 id="Minterm-Predicates"><a href="#Minterm-Predicates" class="headerlink" title="Minterm Predicates"></a>Minterm Predicates</h2><ol>
<li>Let Q = {Q1, Q2… Qk} be a set of queries on relation R, where each Qi = σ pi (R)</li>
<li>Let P = {p1, p2… pk}</li>
<li>Let F = {R1, R2… ,Rm} be the minterm partitioning of R based on MTPred(P)<blockquote>
<p>Theorem: F is a complete partitioning wrt every<br>query in Q</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-2/" data-id="cki7gopf3000zzprvd9lcaedu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-1/" class="article-date">
  <time datetime="2020-11-21T18:52:59.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-1/">Distributed Database System (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Modern-Distributed-DBMS"><a href="#Modern-Distributed-DBMS" class="headerlink" title="Modern Distributed DBMS"></a>Modern Distributed DBMS</h2><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul>
<li>Relational DBMS:<ul>
<li>Initially targeted at business processing<br>applications </li>
<li>OLTP = On-Line Transaction Processing</li>
<li>Characteristics: small update ACID transactions</li>
</ul>
</li>
<li>Early distributed DBMS:<ul>
<li>Targeted to support the organizational structure<br>of distributed enterprises</li>
</ul>
</li>
<li>Parallel DBMS:<ul>
<li>Targeted at decision support systems (DSSs)</li>
<li>OLAP = On-line Analytical Processing</li>
<li>Characteristics: Complex read-mostly queries on large data</li>
</ul>
</li>
</ul>
<h3 id="NewSQL-Database-Systems"><a href="#NewSQL-Database-Systems" class="headerlink" title="NewSQL Database Systems"></a>NewSQL Database Systems</h3><ul>
<li>Targeted at OLTP workloads</li>
<li>Features<ul>
<li>Relational data model</li>
<li>SQL query language</li>
<li>ACID transactions</li>
<li>Runs on distributed cluster of shared-nothing nodes</li>
</ul>
</li>
</ul>
<blockquote>
<p>NewSQL Database Systems: Relational DB can be scaled. It is designed in a distributed way to provide rational DB.</p>
</blockquote>
<h2 id="Review-of-Relational-Algebra"><a href="#Review-of-Relational-Algebra" class="headerlink" title="Review of Relational Algebra"></a>Review of Relational Algebra</h2><ul>
<li><p><code>σA&gt;5</code></p>
<p>SELECT * FROM R WHERE A &gt; 5</p>
</li>
<li><p><code>πX,Y,Z (R)</code></p>
<p>SELECT DISTINCT X, Y, Z FROM R</p>
</li>
<li><p><code>R ⊳⊲A S</code></p>
<p>SELECT * FROM R JOIN S ON R.A = S.A</p>
</li>
<li><p><code>R ⋉A S</code></p>
<p>SELECT * FROM R WHERE EXISTS (SELECT * FROM S WHERE R.A = S.A)</p>
</li>
</ul>
<h2 id="Review-of-ACID-Transactions"><a href="#Review-of-ACID-Transactions" class="headerlink" title="Review of ACID Transactions"></a>Review of ACID Transactions</h2><ul>
<li>Atomicity: Transaction is either executed completely or not at all</li>
<li>Consistency: Transaction preserves database consistency</li>
<li>Isolation: Execution of a Transaction is isolated from other Transaction</li>
<li>Durability: If a Transaction commits, its effects persist</li>
</ul>
<h2 id="Serial-Schedules"><a href="#Serial-Schedules" class="headerlink" title="Serial Schedules:"></a>Serial Schedules:</h2><ul>
<li>所有事务排队，没有并发</li>
</ul>
<h2 id="Serializable-Schedule："><a href="#Serializable-Schedule：" class="headerlink" title="Serializable Schedule："></a>Serializable Schedule：</h2><ul>
<li>有并发，但存在一个完全等价的serial schedule</li>
<li>往往指代conflict serializable，即没有以下：<ul>
<li>Read-write conflict</li>
<li>Write-read conflict</li>
<li>Write-write conflict</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-1/" data-id="cki7gopf2000yzprvdyn19wm0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/12/BigData-8/" class="article-date">
  <time datetime="2020-11-12T17:51:50.000Z" itemprop="datePublished">2020-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/12/BigData-8/">BigData(8)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Data-Stream"><a href="#Data-Stream" class="headerlink" title="Data Stream"></a>Data Stream</h2><p>Data stream is a sequence of items. There are two problems with data stream:</p>
<ul>
<li>We are not able to store all data</li>
<li>We are not able to exam every single item</li>
</ul>
<p>There are multiple challenges faced by stream processing:</p>
<ul>
<li>The data itself is high volume, arrival speed is fast</li>
<li>Machine only has limited memory and storage</li>
<li>The latency requirement is strict</li>
<li>Load balancing</li>
<li>The message delivery is unreliable</li>
<li>Fault tolerance</li>
<li>…</li>
</ul>
<h2 id="General-Strategies"><a href="#General-Strategies" class="headerlink" title="General Strategies"></a>General Strategies</h2><ul>
<li><code>Sampling</code>: Reduce the number of data items</li>
<li><code>Hashing</code>: Reduce computation overhead and/or data size</li>
</ul>
<h2 id="Reservoir-Sampling"><a href="#Reservoir-Sampling" class="headerlink" title="Reservoir Sampling"></a>Reservoir Sampling</h2><p>Usually, if we want to take samples, we need to know all N data points then take the samples. However, for streaming, we might not be able to know what N is. Thus, in the data stream, we need to make a decision to keep a sample or not.</p>
<h3 id="K-1"><a href="#K-1" class="headerlink" title="K = 1"></a>K = 1</h3><p>When k = 1, which means only 1 sample is picked for the whole set of <code>N</code> data items, we will have, the probability of each item be sampled should be <code>1/N</code>.<br>Thus, what we can do is:</p>
<ul>
<li>When 1st item n1 arrives, keep it. p(n1) = 1/1 = 1</li>
<li>When 2nd item n2 arrives, the probability to keep it is <code>1/2</code>, then the probability of taking n1 is: p(n1)= 1 * (1-1/2) = 1/2, and for n2 is p(n2) = 1/2</li>
<li>When 3rd item n3 arrives, the probability to keep it is <code>1/3</code>, then the probability of taking n1 is: p(n1) = 1 * (1-1/2) * (1-1/3) = 1/3. For n2, it is p(n2) = 1/2 * (1-1/3) = 1/3, for n3 is p(n3) = 1/3</li>
<li>…</li>
<li>Thus, for item <code>i</code>, we have p(n1) = p(n2) = .. p(ni-1) = (1/i-1) * (1-1/i) = 1/i, and p(ni) = 1/i</li>
</ul>
<h3 id="K-gt-1"><a href="#K-gt-1" class="headerlink" title="K &gt; 1"></a>K &gt; 1</h3><p>When k &gt; 1, which means multiple samples are picked for the whole set of <code>N</code> data items, we will have, the probability of each item be sampled should be <code>k/N</code>.<br>Thus, what we can do is:</p>
<ul>
<li>For the first <code>k</code> items, the p(n1) = p(n2) = … = p(nk) = 1</li>
<li>For <code>k+1</code>th item, the probability to keep it is <code>k/(k+1)</code>, and the probability to keep the item <code>r</code> inside the first <code>k</code> items is:<br>p(nr) = p(item r was kept in last round) * p(item n+1 is not kept) + p(item n+1 is kept) * p(item r was not replaced by n+1)<br>= <code>(1/k+1) + (k/k+1)*(k-1)/k = k/k+1</code></li>
<li>…</li>
<li>Thus, for item i (i&gt;k), the probability to keep it is <code>k/i</code></li>
</ul>
<h2 id="Flajolet-Martin-FM-counter"><a href="#Flajolet-Martin-FM-counter" class="headerlink" title="Flajolet-Martin(FM) counter"></a>Flajolet-Martin(FM) counter</h2><p>What a FM counter can do? Assume we have 100 billion numbers, how can we find the number of unique numbers out of the 100 billion numbers?</p>
<blockquote>
<p>假设n个object，其中有m个唯一的，那么FM算法只需要log(m)的内存占用（实际操作中会是k*log(m)），以及O(n)的运算时间。当然，FM的问题是，它的结果只是一个估计值，不是精确结果。</p>
</blockquote>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><ul>
<li>If the result is not found, the element does not exist</li>
<li>If the result is found, the element <strong>may</strong> exist</li>
</ul>
<h2 id="Count-Min-Sketches-CMS"><a href="#Count-Min-Sketches-CMS" class="headerlink" title="Count-Min Sketches (CMS)"></a>Count-Min Sketches (CMS)</h2><blockquote>
<p>Count-Min Sketch 是数据库中用到的一种 Sketch，所谓 sketch 就是用很少的一点数据来描述全体数据的特性，牺牲了准确性但是代价变得很低。</p>
</blockquote>
<blockquote>
<p>问题：统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数，那该怎么办？</p>
</blockquote>
<h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><blockquote>
<p>Apache Storm是一个分布式的、可靠的、容错的实时数据流处理框架。它与Spark Streaming的最大区别在于它是逐个处理流式数据事件，而Spark Streaming是微批次处理，因此，它比Spark Streaming更实时。</p>
</blockquote>
<p>Nimbus：即Storm的Master，负责资源分配和任务调度。一个Storm集群只有一个Nimbus。</p>
<p>Supervisor：即Storm的Slave，负责接收Nimbus分配的任务，管理所有Worker，一个Supervisor节点中包含多个Worker进程。</p>
<p>Worker：工作进程，每个工作进程中都有多个Task。</p>
<p>Task：任务，在 Storm 集群中每个 Spout 和 Bolt 都由若干个任务（tasks）来执行。每个任务都与一个执行线程相对应。</p>
<p>Topology：计算拓扑，Storm 的拓扑是对实时计算应用逻辑的封装，它的作用与 MapReduce 的任务（Job）很相似，区别在于 MapReduce 的一个 Job 在得到结果之后总会结束，而拓扑会一直在集群中运行，直到你手动去终止它。拓扑还可以理解成由一系列通过数据流（Stream Grouping）相互关联的 Spout 和 Bolt 组成的的拓扑结构。</p>
<p>Stream：数据流（Streams）是 Storm 中最核心的抽象概念。一个数据流指的是在分布式环境中并行创建、处理的一组元组（tuple）的无界序列。数据流可以由一种能够表述数据流中元组的域（fields）的模式来定义。</p>
<p>Spout：数据源（Spout）是拓扑中数据流的来源。一般 Spout 会从一个外部的数据源读取元组然后将他们发送到拓扑中。根据需求的不同，Spout 既可以定义为可靠的数据源，也可以定义为不可靠的数据源。一个可靠的 Spout 能够在它发送的元组处理失败时重新发送该元组，以确保所有的元组都能得到正确的处理；相对应的，不可靠的 Spout 就不会在元组发送之后对元组进行任何其他的处理。一个 Spout 可以发送多个数据流。</p>
<p>Bolt：拓扑中所有的数据处理均是由 Bolt 完成的。通过数据过滤（filtering）、函数处理（functions）、聚合（aggregations）、联结（joins）、数据库交互等功能，Bolt 几乎能够完成任何一种数据处理需求。一个 Bolt 可以实现简单的数据流转换，而更复杂的数据流变换通常需要使用多个 Bolt 并通过多个步骤完成。</p>
<p>Stream grouping：为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。在 Storm 中有八种内置的数据流分组方式。</p>
<p>Reliability：可靠性。Storm 可以通过拓扑来确保每个发送的元组都能得到正确处理。通过跟踪由 Spout 发出的每个元组构成的元组树可以确定元组是否已经完成处理。每个拓扑都有一个“消息延时”参数，如果 Storm 在延时时间内没有检测到元组是否处理完成，就会将该元组标记为处理失败，并会在稍后重新发送该元组。</p>
<br/>
<br/>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/29178293" target="_blank" rel="noopener">水塘抽样（Reservoir Sampling）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1376934" target="_blank" rel="noopener">什么是水塘抽样算法（Reservoir Sampling）</a></li>
<li><a href="https://greatpowerlaw.wordpress.com/2012/10/14/flajoletmartin/" target="_blank" rel="noopener">Flajolet-Martin算法</a></li>
<li><a href="https://blog.csdn.net/baimafujinji/article/details/6472658" target="_blank" rel="noopener">Flajolet-Martin算法</a></li>
<li><a href="https://florian.github.io/count-min-sketch/" target="_blank" rel="noopener">Count-Min Sketch</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&mid=2649967190&idx=1&sn=67406c916f75c3f2ee59ce05d3f65ea8&chksm=beca3a5089bdb34652a7dbf7b399379f8ccfa3f941c1752dec529b1532018189cb0e4edb12b8&mpshare=1&scene=1&srcid=0622k0SqC0P2ryonJeaM5bVR&pass_ticket=4R9ZWXz%2FDcFGK9tVfysrmusZ3J09OLC1S3R3B%2BhZmqJ6QAiynVx5CyF%2By1Z2dT4Y#rd" target="_blank" rel="noopener">Count-Min Sketch 算法，解决大数据统计难题</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/12/BigData-8/" data-id="cki7gopez000vzprv1k8w1h4g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueJs/" rel="tag">VueJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E6%80%A7/" rel="tag">安全性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 12.5px;">Algorithm</a> <a href="/tags/Big-Data/" style="font-size: 17.5px;">Big Data</a> <a href="/tags/Data-Structure/" style="font-size: 20px;">Data Structure</a> <a href="/tags/Distributed-Database/" style="font-size: 20px;">Distributed Database</a> <a href="/tags/LeetCode/" style="font-size: 12.5px;">LeetCode</a> <a href="/tags/VueJs/" style="font-size: 10px;">VueJs</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">协议</a> <a href="/tags/%E5%AE%89%E5%85%A8%E6%80%A7/" style="font-size: 12.5px;">安全性</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/26/Distributed-Database-System-9/">Distributed Database System (9)</a>
          </li>
        
          <li>
            <a href="/2020/11/26/Distributed-Database-System-8/">Distributed Database System (8)</a>
          </li>
        
          <li>
            <a href="/2020/11/26/Distributed-Database-System-7/">Distributed Database System (7)</a>
          </li>
        
          <li>
            <a href="/2020/11/26/Distributed-Database-System-6/">Distributed Database System (6)</a>
          </li>
        
          <li>
            <a href="/2020/11/22/Distributed-Database-System-5/">Distributed Database System (5)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Shiming Wu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>