<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shiming&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="寄言燕雀莫相啅， 自有云霄万里高。">
<meta property="og:type" content="website">
<meta property="og:title" content="Shiming&#39;s Blog">
<meta property="og:url" content="https://shimingwu.github.io/index.html">
<meta property="og:site_name" content="Shiming&#39;s Blog">
<meta property="og:description" content="寄言燕雀莫相啅， 自有云霄万里高。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shiming Wu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shiming&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shiming&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shimingwu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Distributed-Database-System-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/22/Distributed-Database-System-5/" class="article-date">
  <time datetime="2020-11-22T16:44:23.000Z" itemprop="datePublished">2020-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/22/Distributed-Database-System-5/">Distributed Database System (5)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><ul>
<li>Single-partition transaction: a distributed transaction that access/update items from exactly one site</li>
<li>Multi-partition transaction: a distributed transaction that access/update items from more than one site </li>
</ul>
<h2 id="Schedules"><a href="#Schedules" class="headerlink" title="Schedules"></a>Schedules</h2><ul>
<li>Local schedule: transaction schedule at a local site</li>
<li>Global Schedule: <ul>
<li>Let T = {T1, · · · , Tn} be a set of global transactions executed over m sites with local schedules {S1, · · · , Sm}</li>
<li>A schedule S is a global schedule for T and {S1, · · · , Sm} if each Si is a subsequence of S</li>
</ul>
</li>
</ul>
<h2 id="Concurrency-Control-Protocols"><a href="#Concurrency-Control-Protocols" class="headerlink" title="Concurrency Control Protocols"></a>Concurrency Control Protocols</h2><ul>
<li>Lock-based protocols</li>
<li>Timestamp-based protocols</li>
<li>Optimistic protocols</li>
<li>Mutiversion protocols</li>
<li>Hybrid protocols</li>
</ul>
<h1 id="Distributed-Lock-based-Protocols"><a href="#Distributed-Lock-based-Protocols" class="headerlink" title="Distributed Lock-based Protocols"></a>Distributed Lock-based Protocols</h1><ul>
<li>Centralized 2PL (C2PL)<ul>
<li>1个site作为central site管理lock</li>
<li>Coordinating Site每次读 x 时，都和Central site说一声</li>
</ul>
</li>
<li>Distributed 2PL (D2PL)<ul>
<li>每个site上面都有一个lock manager，各自管理</li>
</ul>
</li>
</ul>
<h2 id="Two-Phase-Locking-2PL-Protocol"><a href="#Two-Phase-Locking-2PL-Protocol" class="headerlink" title="Two Phase Locking (2PL) Protocol"></a>Two Phase Locking (2PL) Protocol</h2><blockquote>
<p>2PL schedules are conflict serializable</p>
</blockquote>
<ul>
<li>Growing phase: before releasing 1st lock</li>
<li>Shrinking phase: after releasing 1st lock</li>
</ul>
<ol>
<li>To read an object O, a Xact must hold a S-lock or X-lock on O</li>
<li>To write to an object O, a Xact must hold a X-lock on O</li>
<li>Once a Xact releases a lock, the Xact can’t request any more<br>locks</li>
</ol>
<h2 id="Strict-Two-Phase-Locking-S2PL"><a href="#Strict-Two-Phase-Locking-S2PL" class="headerlink" title="Strict Two Phase Locking (S2PL)"></a>Strict Two Phase Locking (S2PL)</h2><blockquote>
<p>Strict 2PL schedules are conflict<br>serializable &amp; recoverable</p>
</blockquote>
<ol>
<li>To read an object O, a Xact must hold a S-lock or X-lock on O</li>
<li>To write to an object O, a Xact must hold a X-lock on O</li>
<li>A Xact must hold on to locks until Xact commits or aborts</li>
</ol>
<h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><ul>
<li>Waits-for graph (WFG)<ul>
<li>Deadlock is detected if WFG has a cycle</li>
</ul>
</li>
</ul>
<h2 id="Distributed-Deadlock-Detection"><a href="#Distributed-Deadlock-Detection" class="headerlink" title="Distributed Deadlock Detection"></a>Distributed Deadlock Detection</h2><ul>
<li>Centralized approach<ul>
<li>每一个site都有一个Local Wait-For Graph (LWFG)</li>
<li>阶段性地发给deadlock detector去检测。deadlock detector会将所有site的LWFG组合成Global Wait-For Graph (GWFG)并且检查是否有闭环。</li>
</ul>
</li>
<li>Distributed approaches</li>
</ul>
<h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><ul>
<li>Each Xact is assigned a unique start timestamp</li>
<li>Wait-die policy<ul>
<li>如果事务A晚于事务B开始，那么事务A等待另外一个事务释放对应资源的锁或者直接abort。</li>
</ul>
</li>
<li>Wound-wait policy<ul>
<li>如果事务A早于事务B开始，那么事务A等待，或者abort。这是一种抢占方案。</li>
</ul>
</li>
</ul>
<h1 id="Timestamp-based-protocols"><a href="#Timestamp-based-protocols" class="headerlink" title="Timestamp-based protocols"></a>Timestamp-based protocols</h1><ul>
<li>Centralized Snapshot Isolation (CSI)<ul>
<li>一个site作为Centralized Coordinator (CC)，负责管理所有start和commit的时间戳（timestamp）的分发</li>
<li>TC会从CC上获取需要的timestamp，但是不管是对Write还是Read，lock都由TC各自管理</li>
</ul>
</li>
<li>Distributed Snapshot Isolation (DSI)</li>
</ul>
<h2 id="Snapshot-Isolation-（SI）"><a href="#Snapshot-Isolation-（SI）" class="headerlink" title="Snapshot Isolation （SI）"></a>Snapshot Isolation （SI）</h2><ul>
<li>Write: 不同的transaction各自写各自的事务时，看谁的commit的时间更晚</li>
<li>Read：只读commit最晚的</li>
</ul>
<p>SI不一定是serializable。</p>
<h2 id="Multiversion-Concurrency-Control-MVCC"><a href="#Multiversion-Concurrency-Control-MVCC" class="headerlink" title="Multiversion Concurrency Control (MVCC)"></a>Multiversion Concurrency Control (MVCC)</h2><p>在MVCC之前，主要采用”two-phase locking”，但”two-phase locking”过程中需要对读写操作进行加锁，这会带来显著的性能问题。因此，”two-phase locking”在读写高并发场景中已被逐步摒弃。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/22/Distributed-Database-System-5/" data-id="ckhsvnfxg0014zxr1bwf41r19" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/22/Distributed-Database-System-4/" class="article-date">
  <time datetime="2020-11-22T12:40:10.000Z" itemprop="datePublished">2020-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/22/Distributed-Database-System-4/">Distributed Database System (4)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol>
<li>Atomicity: Either all or none of the actions in transactions happen (recovery manager)</li>
<li>Consistency: If each transaction is consistent and the DB starts consistent, it ends up consistent</li>
<li>Isolation: Execution of one transaction is isolated from other transactions (concurrency control manager)</li>
<li>Durability: If a transaction commits, its effects persist (recovery manager)</li>
</ol>
<h2 id="Recovery-Manager"><a href="#Recovery-Manager" class="headerlink" title="Recovery Manager"></a>Recovery Manager</h2><ul>
<li>Commit(T): installs T’s updated pages into stable database</li>
<li>Abort(T): restores all data that T updated to their prior values</li>
<li>Restart(T): recovers database to a consistent state from system<br>failure<ul>
<li>aborts all active Xacts at the time of system failure</li>
<li>installs updates of all committed Xacts that were not installed in the stable database before the failure</li>
</ul>
</li>
</ul>
<h3 id="Log-based-Database-Recovery"><a href="#Log-based-Database-Recovery" class="headerlink" title="Log-based Database Recovery"></a>Log-based Database Recovery</h3><ul>
<li><p>Commit</p>
<ul>
<li>Force-at-commit protocol</li>
</ul>
</li>
<li><p>Abort</p>
<ul>
<li>Write-ahead logging (WAL) protocol</li>
</ul>
<p>在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中</p>
</li>
<li><p>Restart</p>
<ul>
<li>Redo phase: scans log and keeps track of active Xacts</li>
<li>Undo phase: aborts all active Xacts</li>
</ul>
</li>
</ul>
<h2 id="Distributed-Transactions"><a href="#Distributed-Transactions" class="headerlink" title="Distributed Transactions"></a>Distributed Transactions</h2><ul>
<li>Transaction coordinator (TC)</li>
<li>Transaction manager (TM)</li>
</ul>
<br/>
<img src="/2020/11/22/Distributed-Database-System-4/TMTC.png" class="" title="TMTC">
<br/>

<h2 id="Failures-in-Distributed-DBMS"><a href="#Failures-in-Distributed-DBMS" class="headerlink" title="Failures in Distributed DBMS"></a>Failures in Distributed DBMS</h2><ul>
<li>Site failures<ul>
<li>Fail-stop model: A site is either working correctly (i.e.operational) or not working at all (i.e. failed)</li>
<li>Partial site failure: Some site(s) are operational &amp; some site(s) are down</li>
<li>Total site failure: All sites are down</li>
</ul>
</li>
<li>Communication failures<ul>
<li>Lost messages, network partitioning, etc.</li>
</ul>
</li>
</ul>
<h2 id="Two-Phase-Commit-2PC-Protocol"><a href="#Two-Phase-Commit-2PC-Protocol" class="headerlink" title="Two-Phase Commit (2PC) Protocol"></a>Two-Phase Commit (2PC) Protocol</h2><ul>
<li>Voting/Preparation Phase: coordinator从participants那儿收集votes</li>
<li>Decision Phase：coordinator会将global decision发送给所有的participants （只要有一个abort就全部abort）</li>
</ul>
<h2 id="Dealing-with-Site-Failures"><a href="#Dealing-with-Site-Failures" class="headerlink" title="Dealing with Site Failures"></a>Dealing with Site Failures</h2><h3 id="Recovery-Protocols-for-2PC"><a href="#Recovery-Protocols-for-2PC" class="headerlink" title="Recovery Protocols for 2PC"></a>Recovery Protocols for 2PC</h3><p><strong>Coordinator Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>直接resume INITIAL状态</li>
</ul>
</li>
<li>Fails in WAIT state： <ul>
<li>重新发送prepare消息</li>
</ul>
</li>
<li>Fails in COMMIT/ABORT state<ul>
<li>如果已经收到了所有的ACK消息，则不做任何事</li>
<li>否则，将之前的Global-commit/Global-abort的决定再次发送</li>
</ul>
</li>
</ul>
<p><strong>Participant Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>单方面abort</li>
</ul>
</li>
<li>Fails in READY state： <ul>
<li>如果一个participant进入了READY状态，这就证明它之前已经发送了vote-commit</li>
<li>重新发送vote-commit</li>
</ul>
</li>
<li>Fails in ABORT state：<ul>
<li>不做任何事</li>
</ul>
</li>
<li>Fails in COMMIT state：<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<h3 id="Termination-Protocols-for-2PC"><a href="#Termination-Protocols-for-2PC" class="headerlink" title="Termination Protocols for 2PC"></a>Termination Protocols for 2PC</h3><ul>
<li>Basic Termination Protocol</li>
<li>Cooperative Termination Protocol</li>
</ul>
<p><strong>Basic Termination Protocol</strong></p>
<ul>
<li><p>Cooordinator Timeouts</p>
<ul>
<li>Timeout in WAIT state<ul>
<li>等待所有participant的vote的时候超时了，则写入log并且发送Global-abort</li>
</ul>
</li>
<li>Timeout in COMMIT/ABORT state<ul>
<li>等待所有participant的ACK的时候超时了，则对没有回复的participant再次发送Global-commit/Global-abort</li>
</ul>
</li>
</ul>
</li>
<li><p>Participant Timeouts</p>
<ul>
<li><p>Timeout in INITIAL state</p>
<ul>
<li>等待prepare消息，可以单方面abort</li>
</ul>
</li>
<li><p>Timeout in READY state</p>
<ul>
<li><strong>必须等待coordinator的指令</strong></li>
</ul>
<blockquote>
<p>2PC算法可以正确处理其他participant的failure，因为coordinator可以发送适当的指令。但是当coordinator宕机时，它必须等到coordinator发送消息才可以继续执行commit/abort，所以被阻塞了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>Cooperative Termination Protocol</strong></p>
<p>为了防止刚刚阻塞的情况发生，Cooperative Termination Protocol决定允许participant与其他participants沟通来获取commit/abort情况。</p>
<ul>
<li><p>Participant Timeouts</p>
<ul>
<li><p>Timeout in READY state</p>
<ul>
<li>首先participant会有一个其他所有participants的地址列表</li>
<li>发送decision-request消息给所有其他participants<ul>
<li>对于其他收到decision-request的participant Q 而言</li>
<li>如果是INITIAL state，则回复”abort”</li>
<li>如果是READY，则回复”Uncertain”</li>
<li>如果是COMMIT/ABORT, 则回复决定</li>
</ul>
</li>
<li>收到任何决定（不管是Commit/abort）都执行</li>
<li>如果也有收到”Uncertain”，则把决定传给那些不知道的participant</li>
</ul>
<blockquote>
<p>这个protocol只能帮助减少阻塞，但不能完全解决。因为当所有人都在READY状态下，则大家还是必须等coordinator的指示。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Three-Phase-Commit-3PC-Protocol"><a href="#Three-Phase-Commit-3PC-Protocol" class="headerlink" title="Three-Phase Commit (3PC) Protocol"></a>Three-Phase Commit (3PC) Protocol</h2><ul>
<li>Voting/Preparation phase<ul>
<li>Coordinator collects votes from participants</li>
</ul>
</li>
<li>Dissemination (传播) phase<ul>
<li>Coordinator disseminates voting outcome to participants if there is no abort vote</li>
</ul>
</li>
<li>Decision phase<ul>
<li>Coordinator sends global decision to participants</li>
</ul>
</li>
</ul>
<h3 id="Recovery-Protocols-for-3PC"><a href="#Recovery-Protocols-for-3PC" class="headerlink" title="Recovery Protocols for 3PC"></a>Recovery Protocols for 3PC</h3><p><strong>Coordinator Site Failures</strong></p>
<ul>
<li>Fails in INITIAL/PRECOMMIT state： <ul>
<li>和participant询问</li>
</ul>
</li>
<li>Fails in COMMIT/ABORT state<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<p><strong>Participant Site Failures</strong></p>
<ul>
<li>Fails in INITIAL state： <ul>
<li>单方面abort</li>
</ul>
</li>
<li>Fails in READY/PRECOMMIT state： <ul>
<li>和participant询问</li>
</ul>
</li>
<li>Fails in ABORT/COMMIT state：<ul>
<li>不做任何事</li>
</ul>
</li>
</ul>
<h3 id="Termination-Protocols-for-3PC"><a href="#Termination-Protocols-for-3PC" class="headerlink" title="Termination Protocols for 3PC"></a>Termination Protocols for 3PC</h3><ul>
<li><p>Cooordinator Timeouts</p>
<ul>
<li>Timeout in WAIT state<ul>
<li>等待所有participant的vote的时候超时了，则写入log并且发送Global-abort</li>
</ul>
</li>
<li>Timeout in PRECOMMIT state<ul>
<li>PRECOMMIT代表了所有的participant都vote for commit</li>
<li>对没有回复的participant再次发送prepare-to-commit消息</li>
<li>对其他有回复的participant发送Global-commit消息</li>
</ul>
</li>
<li>Timeout in COMMIT state<ul>
<li>Coordinator在等ACK</li>
<li>因为已知能进入COMMIT状态代表了所有的participants都在PRECOMMIT/COMMIT，所以对其他没有回复的participant发送Global-commit消息</li>
</ul>
</li>
<li>Timeout in ABORT state<ul>
<li>Coordinator在等ACK</li>
<li>因为已知能进入ABORT状态代表了所有的participants都在READY/ABORT，所以对其他没有回复的participant发送Global-abort消息</li>
</ul>
</li>
</ul>
</li>
<li><p>Participant Timeouts</p>
<ul>
<li>Timeout in INITIAL state<ul>
<li>可以单方面abort</li>
</ul>
</li>
<li>Timeout in READY state<ul>
<li>执行New Coordinator Termination Protocol</li>
</ul>
</li>
<li>Timeout in PRECOMMIT state<ul>
<li>执行New Coordinator Termination Protocol</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>New Coordinator Termination Protocol</strong></p>
<p>选取新的coordinator。</p>
<ul>
<li>Participant Timeouts<ul>
<li>Timeout in READY/PRECOMMIT state<ul>
<li>首先participant会有一个其他所有participants的地址列表</li>
<li>选举出来的新的coordinator会发送State-request message消息给所有其他participants<ul>
<li>如果有些participant是COMMIT state，则对所有人发送”global-commit”</li>
<li>否则，如果没有participant是PRECOMMIT state，则对所有人发送”global-abort”</li>
<li>如果上面两种情况都没有，则对所有人发送Prepare-to-commit，收到Prepare-to-commit的话就对其他的participants发送”global-commit”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/22/Distributed-Database-System-4/" data-id="ckhsvnfxf0012zxr1hxx11me3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-3/" class="article-date">
  <time datetime="2020-11-21T21:09:22.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-3/">Distributed Database System (3)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="LSM-Storage"><a href="#LSM-Storage" class="headerlink" title="LSM Storage"></a>LSM Storage</h2><p>LSM storage for a relation R(K, V) consists of:</p>
<ul>
<li>A main-memory structure MemTable</li>
<li>A set of disk-based structures SSTables</li>
<li>A commit log file</li>
</ul>
<h3 id="MemTable-Memory-Table"><a href="#MemTable-Memory-Table" class="headerlink" title="MemTable (Memory Table)"></a>MemTable (Memory Table)</h3><ul>
<li>Contains the most recent updates organized in main-memory</li>
<li>MemTable is updated in-place<ul>
<li>Deleted records are not removed but marked with tombstones (denoted by ⊥)</li>
</ul>
</li>
<li>When size of MemTable reaches a certain threshold, the records in MemTable are sorted and flushed to disk as a new SSTable</li>
</ul>
<h3 id="SSTable-Sorted-String-Table"><a href="#SSTable-Sorted-String-Table" class="headerlink" title="SSTable (Sorted String Table)"></a>SSTable (Sorted String Table)</h3><ul>
<li>SSTables are immutable structures</li>
<li>SSTable records are <strong>sorted</strong> by relation’s key K</li>
<li>Each SSTable is associated with a range of key values &amp; a timestamp</li>
</ul>
<h3 id="Commit-Log-File"><a href="#Commit-Log-File" class="headerlink" title="Commit Log File"></a>Commit Log File</h3><ul>
<li>A commit log file is used to ensure durability</li>
<li>Each new update is appended to commit log &amp; updated to MemTable</li>
</ul>
<h2 id="Compaction-of-SSTables"><a href="#Compaction-of-SSTables" class="headerlink" title="Compaction of SSTables"></a>Compaction of SSTables</h2><p>Compaction helps to improve:</p>
<ul>
<li>Read performance by defragmenting table records</li>
<li>Improves space utilization by eliminating tombstones &amp; stale values</li>
</ul>
<h3 id="Compaction-Strategies"><a href="#Compaction-Strategies" class="headerlink" title="Compaction Strategies"></a>Compaction Strategies</h3><ul>
<li>Size-tiered Compaction Strategy (STCS)</li>
<li>Leveled Compaction Strategy (LCS)</li>
</ul>
<h2 id="Local-vs-Global-Indexing"><a href="#Local-vs-Global-Indexing" class="headerlink" title="Local vs Global Indexing"></a>Local vs Global Indexing</h2><p>Advantage of using local index: Update will be easier with local index. The index is associated with data stored in the same site.</p>
<p>Advantage of using global index, search will be easier. We only need to retrieve all the entries from one site.</p>
<h2 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h2><ul>
<li>B+-tree<ul>
<li>Updates are performed in-place </li>
<li>Posting list for each key is stored together</li>
<li>Example: MongoDB</li>
</ul>
</li>
<li>LSM Storage <ul>
<li>Updates are performed with append-only updates</li>
<li>Posting list for each key could be fragmented across multiple SSTables</li>
<li>Example: Cassandra</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-3/" data-id="ckhsvnfxd000zzxr122jd3y5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-2/" class="article-date">
  <time datetime="2020-11-21T20:18:24.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-2/">Distributed Database System (2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Distributed-Database-Design"><a href="#Distributed-Database-Design" class="headerlink" title="Distributed Database Design"></a>Distributed Database Design</h2><ul>
<li><code>Data fragmentation / partitioning</code>: how to<br>partition data into smaller pieces</li>
<li><code>Data allocation</code>: how to allocate data to various<br>sites</li>
<li><code>Data replication</code>: what data to replicate at each<br>site</li>
</ul>
<h2 id="Data-Fragmentation"><a href="#Data-Fragmentation" class="headerlink" title="Data Fragmentation"></a>Data Fragmentation</h2><p>There are three strategies used:</p>
<ul>
<li>Horizontal fragmentation (sharding)</li>
<li>Vertical fragmentation (Schema decomposition)</li>
<li>Hybrid fragmentation</li>
</ul>
<h3 id="Desirable-Properties-of-Fragmentation"><a href="#Desirable-Properties-of-Fragmentation" class="headerlink" title="Desirable Properties of Fragmentation"></a>Desirable Properties of Fragmentation</h3><ul>
<li>Completeness: <ul>
<li>在原R里面能找到的元素一定能在被碎片化后的R的set里面找到</li>
<li><code>∀t ∈ R, ∃ Ri such that t ∈ Ri</code> (<code>∀: for all</code>, <code>∃: there exists exactly one</code>, for all ts belongs to set R, there exists one Ri such that t will belong to.)</li>
</ul>
</li>
<li>Reconstruction：<ul>
<li>可以使用{R1, R2… Rn}还原R</li>
<li><code>R = R1 ∪ · · · ∪ Rn</code></li>
</ul>
</li>
<li>Disjointness: <ul>
<li>Horizontal Decomposition: 如果一个元素在R1里面找到，它就不会出现在其他Rx里面，即R1与其他任何R的交集都是空集</li>
<li>Vertical Decomposition：这个属性只用于non-primary key</li>
<li><code>∀ Ri ,Rj (i ！= j ⇒ Ri ∩ Rj = ∅)</code> </li>
</ul>
</li>
</ul>
<h2 id="Horizontal-fragmentation"><a href="#Horizontal-fragmentation" class="headerlink" title="Horizontal fragmentation"></a>Horizontal fragmentation</h2><h3 id="Techniques："><a href="#Techniques：" class="headerlink" title="Techniques："></a>Techniques：</h3><ul>
<li>Range Partitioning<ul>
<li>Partition R using predicates on some attributes<br>of R</li>
<li>R1 = σ A &lt; 100 (R) (Select all elements in R that is smaller than 100)</li>
<li>R2 = σ A &gt;= 100 (R) (Select all elements in R that is greater or equal than 100)</li>
</ul>
</li>
<li>Hash Partitioning<ul>
<li>Partition R into {R1, · · · ,Rn} based on hash function on some attribute of R (say R.A). 对某个attribute使用hash function来区分</li>
<li>Modulo method<ul>
<li>Problems: <ol>
<li>Uneven distribution</li>
<li>Difficult to add in new server, need to rehash all existing entries</li>
</ol>
</li>
</ul>
</li>
<li>Consistent Hashing<ul>
<li>Problems:<ol>
<li>Uneven distribution</li>
<li>Heterogeneity of servers’ performance</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Primary Horizontal fragmentation<ul>
<li>Fragmentation predicate Fi: Ri = σ Fi(R)</li>
<li>根据已知需要执行的query来进行range partition</li>
<li>Primary Horizontal fragmentation是一个加强版的range partition</li>
</ul>
</li>
<li>Derived Horizontal Fragmentation<ul>
<li>为了completeness, R.A ⊆ S.A</li>
<li>为了disjointness, S.A must be a key</li>
</ul>
</li>
</ul>
<h2 id="Vertical-fragmentation"><a href="#Vertical-fragmentation" class="headerlink" title="Vertical fragmentation"></a>Vertical fragmentation</h2><h3 id="Attribute-affinity-measure"><a href="#Attribute-affinity-measure" class="headerlink" title="Attribute affinity measure"></a>Attribute affinity measure</h3>

<p>Higher value means higher chance the 2 attributes will be queried together, therefore, we should group the attributes together.</p>
<h2 id="Hybrid-fragmentation"><a href="#Hybrid-fragmentation" class="headerlink" title="Hybrid fragmentation"></a>Hybrid fragmentation</h2><p>Combinations of horizontal/vertical fragmentation.</p>
<h2 id="Complete-Partitioning-wrt-Query"><a href="#Complete-Partitioning-wrt-Query" class="headerlink" title="Complete Partitioning wrt Query"></a>Complete Partitioning wrt Query</h2><p>假设F = {R1, R2, R3.. Rn}。<br>假设Q是在R上面执行的query。<br>执行了Q后，得到的Rx包含了所有的Q所需要的tuples，以及没有包含任何Q所不需要的tuples，那么F是R对于Q的complete partitioning。</p>
<h2 id="Minterm-Predicates"><a href="#Minterm-Predicates" class="headerlink" title="Minterm Predicates"></a>Minterm Predicates</h2><ol>
<li>Let Q = {Q1, Q2… Qk} be a set of queries on relation R, where each Qi = σ pi (R)</li>
<li>Let P = {p1, p2… pk}</li>
<li>Let F = {R1, R2… ,Rm} be the minterm partitioning of R based on MTPred(P)<blockquote>
<p>Theorem: F is a complete partitioning wrt every<br>query in Q</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-2/" data-id="ckhsvnfxc000xzxr1g7go5ryo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Distributed-Database-System-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Distributed-Database-System-1/" class="article-date">
  <time datetime="2020-11-21T18:52:59.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/21/Distributed-Database-System-1/">Distributed Database System (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5424 Distributed Databases.</p>
<h2 id="Modern-Distributed-DBMS"><a href="#Modern-Distributed-DBMS" class="headerlink" title="Modern Distributed DBMS"></a>Modern Distributed DBMS</h2><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul>
<li>Relational DBMS:<ul>
<li>Initially targeted at business processing<br>applications </li>
<li>OLTP = On-Line Transaction Processing</li>
<li>Characteristics: small update ACID transactions</li>
</ul>
</li>
<li>Early distributed DBMS:<ul>
<li>Targeted to support the organizational structure<br>of distributed enterprises</li>
</ul>
</li>
<li>Parallel DBMS:<ul>
<li>Targeted at decision support systems (DSSs)</li>
<li>OLAP = On-line Analytical Processing</li>
<li>Characteristics: Complex read-mostly queries on large data</li>
</ul>
</li>
</ul>
<h3 id="NewSQL-Database-Systems"><a href="#NewSQL-Database-Systems" class="headerlink" title="NewSQL Database Systems"></a>NewSQL Database Systems</h3><ul>
<li>Targeted at OLTP workloads</li>
<li>Features<ul>
<li>Relational data model</li>
<li>SQL query language</li>
<li>ACID transactions</li>
<li>Runs on distributed cluster of shared-nothing nodes</li>
</ul>
</li>
</ul>
<blockquote>
<p>NewSQL Database Systems: Relational DB can be scaled. It is designed in a distributed way to provide rational DB.</p>
</blockquote>
<h2 id="Review-of-Relational-Algebra"><a href="#Review-of-Relational-Algebra" class="headerlink" title="Review of Relational Algebra"></a>Review of Relational Algebra</h2><ul>
<li><p><code>σA&gt;5</code></p>
<p>SELECT * FROM R WHERE A &gt; 5</p>
</li>
<li><p><code>πX,Y,Z (R)</code></p>
<p>SELECT DISTINCT X, Y, Z FROM R</p>
</li>
<li><p><code>R ⊳⊲A S</code></p>
<p>SELECT * FROM R JOIN S ON R.A = S.A</p>
</li>
<li><p><code>R ⋉A S</code></p>
<p>SELECT * FROM R WHERE EXISTS (SELECT * FROM S WHERE R.A = S.A)</p>
</li>
</ul>
<h2 id="Review-of-ACID-Transactions"><a href="#Review-of-ACID-Transactions" class="headerlink" title="Review of ACID Transactions"></a>Review of ACID Transactions</h2><ul>
<li>Atomicity: Transaction is either executed completely or not at all</li>
<li>Consistency: Transaction preserves database consistency</li>
<li>Isolation: Execution of a Transaction is isolated from other Transaction</li>
<li>Durability: If a Transaction commits, its effects persist</li>
</ul>
<h2 id="Serial-Schedules"><a href="#Serial-Schedules" class="headerlink" title="Serial Schedules:"></a>Serial Schedules:</h2><ul>
<li>所有事务排队，没有并发</li>
</ul>
<h2 id="Serializable-Schedule："><a href="#Serializable-Schedule：" class="headerlink" title="Serializable Schedule："></a>Serializable Schedule：</h2><ul>
<li>有并发，但存在一个完全等价的serial schedule</li>
<li>往往指代conflict serializable，即没有以下：<ul>
<li>Read-write conflict</li>
<li>Write-read conflict</li>
<li>Write-write conflict</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/21/Distributed-Database-System-1/" data-id="ckhsvnfxb000vzxr101h7cmds" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/12/BigData-8/" class="article-date">
  <time datetime="2020-11-12T17:51:50.000Z" itemprop="datePublished">2020-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/12/BigData-8/">BigData(8)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Data-Stream"><a href="#Data-Stream" class="headerlink" title="Data Stream"></a>Data Stream</h2><p>Data stream is a sequence of items. There are two problems with data stream:</p>
<ul>
<li>We are not able to store all data</li>
<li>We are not able to exam every single item</li>
</ul>
<p>There are multiple challenges faced by stream processing:</p>
<ul>
<li>The data itself is high volume, arrival speed is fast</li>
<li>Machine only has limited memory and storage</li>
<li>The latency requirement is strict</li>
<li>Load balancing</li>
<li>The message delivery is unreliable</li>
<li>Fault tolerance</li>
<li>…</li>
</ul>
<h2 id="General-Strategies"><a href="#General-Strategies" class="headerlink" title="General Strategies"></a>General Strategies</h2><ul>
<li><code>Sampling</code>: Reduce the number of data items</li>
<li><code>Hashing</code>: Reduce computation overhead and/or data size</li>
</ul>
<h2 id="Reservoir-Sampling"><a href="#Reservoir-Sampling" class="headerlink" title="Reservoir Sampling"></a>Reservoir Sampling</h2><p>Usually, if we want to take samples, we need to know all N data points then take the samples. However, for streaming, we might not be able to know what N is. Thus, in the data stream, we need to make a decision to keep a sample or not.</p>
<h3 id="K-1"><a href="#K-1" class="headerlink" title="K = 1"></a>K = 1</h3><p>When k = 1, which means only 1 sample is picked for the whole set of <code>N</code> data items, we will have, the probability of each item be sampled should be <code>1/N</code>.<br>Thus, what we can do is:</p>
<ul>
<li>When 1st item n1 arrives, keep it. p(n1) = 1/1 = 1</li>
<li>When 2nd item n2 arrives, the probability to keep it is <code>1/2</code>, then the probability of taking n1 is: p(n1)= 1 * (1-1/2) = 1/2, and for n2 is p(n2) = 1/2</li>
<li>When 3rd item n3 arrives, the probability to keep it is <code>1/3</code>, then the probability of taking n1 is: p(n1) = 1 * (1-1/2) * (1-1/3) = 1/3. For n2, it is p(n2) = 1/2 * (1-1/3) = 1/3, for n3 is p(n3) = 1/3</li>
<li>…</li>
<li>Thus, for item <code>i</code>, we have p(n1) = p(n2) = .. p(ni-1) = (1/i-1) * (1-1/i) = 1/i, and p(ni) = 1/i</li>
</ul>
<h3 id="K-gt-1"><a href="#K-gt-1" class="headerlink" title="K &gt; 1"></a>K &gt; 1</h3><p>When k &gt; 1, which means multiple samples are picked for the whole set of <code>N</code> data items, we will have, the probability of each item be sampled should be <code>k/N</code>.<br>Thus, what we can do is:</p>
<ul>
<li>For the first <code>k</code> items, the p(n1) = p(n2) = … = p(nk) = 1</li>
<li>For <code>k+1</code>th item, the probability to keep it is <code>k/(k+1)</code>, and the probability to keep the item <code>r</code> inside the first <code>k</code> items is:<br>p(nr) = p(item r was kept in last round) * p(item n+1 is not kept) + p(item n+1 is kept) * p(item r was not replaced by n+1)<br>= <code>(1/k+1) + (k/k+1)*(k-1)/k = k/k+1</code></li>
<li>…</li>
<li>Thus, for item i (i&gt;k), the probability to keep it is <code>k/i</code></li>
</ul>
<h2 id="Flajolet-Martin-FM-counter"><a href="#Flajolet-Martin-FM-counter" class="headerlink" title="Flajolet-Martin(FM) counter"></a>Flajolet-Martin(FM) counter</h2><p>What a FM counter can do? Assume we have 100 billion numbers, how can we find the number of unique numbers out of the 100 billion numbers?</p>
<blockquote>
<p>假设n个object，其中有m个唯一的，那么FM算法只需要log(m)的内存占用（实际操作中会是k*log(m)），以及O(n)的运算时间。当然，FM的问题是，它的结果只是一个估计值，不是精确结果。</p>
</blockquote>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><ul>
<li>If the result is not found, the element does not exist</li>
<li>If the result is found, the element <strong>may</strong> exist</li>
</ul>
<h2 id="Count-Min-Sketches-CMS"><a href="#Count-Min-Sketches-CMS" class="headerlink" title="Count-Min Sketches (CMS)"></a>Count-Min Sketches (CMS)</h2><blockquote>
<p>Count-Min Sketch 是数据库中用到的一种 Sketch，所谓 sketch 就是用很少的一点数据来描述全体数据的特性，牺牲了准确性但是代价变得很低。</p>
</blockquote>
<blockquote>
<p>问题：统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数，那该怎么办？</p>
</blockquote>
<h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><blockquote>
<p>Apache Storm是一个分布式的、可靠的、容错的实时数据流处理框架。它与Spark Streaming的最大区别在于它是逐个处理流式数据事件，而Spark Streaming是微批次处理，因此，它比Spark Streaming更实时。</p>
</blockquote>
<p>Nimbus：即Storm的Master，负责资源分配和任务调度。一个Storm集群只有一个Nimbus。</p>
<p>Supervisor：即Storm的Slave，负责接收Nimbus分配的任务，管理所有Worker，一个Supervisor节点中包含多个Worker进程。</p>
<p>Worker：工作进程，每个工作进程中都有多个Task。</p>
<p>Task：任务，在 Storm 集群中每个 Spout 和 Bolt 都由若干个任务（tasks）来执行。每个任务都与一个执行线程相对应。</p>
<p>Topology：计算拓扑，Storm 的拓扑是对实时计算应用逻辑的封装，它的作用与 MapReduce 的任务（Job）很相似，区别在于 MapReduce 的一个 Job 在得到结果之后总会结束，而拓扑会一直在集群中运行，直到你手动去终止它。拓扑还可以理解成由一系列通过数据流（Stream Grouping）相互关联的 Spout 和 Bolt 组成的的拓扑结构。</p>
<p>Stream：数据流（Streams）是 Storm 中最核心的抽象概念。一个数据流指的是在分布式环境中并行创建、处理的一组元组（tuple）的无界序列。数据流可以由一种能够表述数据流中元组的域（fields）的模式来定义。</p>
<p>Spout：数据源（Spout）是拓扑中数据流的来源。一般 Spout 会从一个外部的数据源读取元组然后将他们发送到拓扑中。根据需求的不同，Spout 既可以定义为可靠的数据源，也可以定义为不可靠的数据源。一个可靠的 Spout 能够在它发送的元组处理失败时重新发送该元组，以确保所有的元组都能得到正确的处理；相对应的，不可靠的 Spout 就不会在元组发送之后对元组进行任何其他的处理。一个 Spout 可以发送多个数据流。</p>
<p>Bolt：拓扑中所有的数据处理均是由 Bolt 完成的。通过数据过滤（filtering）、函数处理（functions）、聚合（aggregations）、联结（joins）、数据库交互等功能，Bolt 几乎能够完成任何一种数据处理需求。一个 Bolt 可以实现简单的数据流转换，而更复杂的数据流变换通常需要使用多个 Bolt 并通过多个步骤完成。</p>
<p>Stream grouping：为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。在 Storm 中有八种内置的数据流分组方式。</p>
<p>Reliability：可靠性。Storm 可以通过拓扑来确保每个发送的元组都能得到正确处理。通过跟踪由 Spout 发出的每个元组构成的元组树可以确定元组是否已经完成处理。每个拓扑都有一个“消息延时”参数，如果 Storm 在延时时间内没有检测到元组是否处理完成，就会将该元组标记为处理失败，并会在稍后重新发送该元组。</p>
<br/>
<br/>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/29178293" target="_blank" rel="noopener">水塘抽样（Reservoir Sampling）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1376934" target="_blank" rel="noopener">什么是水塘抽样算法（Reservoir Sampling）</a></li>
<li><a href="https://greatpowerlaw.wordpress.com/2012/10/14/flajoletmartin/" target="_blank" rel="noopener">Flajolet-Martin算法</a></li>
<li><a href="https://blog.csdn.net/baimafujinji/article/details/6472658" target="_blank" rel="noopener">Flajolet-Martin算法</a></li>
<li><a href="https://florian.github.io/count-min-sketch/" target="_blank" rel="noopener">Count-Min Sketch</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&mid=2649967190&idx=1&sn=67406c916f75c3f2ee59ce05d3f65ea8&chksm=beca3a5089bdb34652a7dbf7b399379f8ccfa3f941c1752dec529b1532018189cb0e4edb12b8&mpshare=1&scene=1&srcid=0622k0SqC0P2ryonJeaM5bVR&pass_ticket=4R9ZWXz%2FDcFGK9tVfysrmusZ3J09OLC1S3R3B%2BhZmqJ6QAiynVx5CyF%2By1Z2dT4Y#rd" target="_blank" rel="noopener">Count-Min Sketch 算法，解决大数据统计难题</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/12/BigData-8/" data-id="ckhsvnfxa000uzxr1erhp7zbo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/10/BigData-7/" class="article-date">
  <time datetime="2020-11-10T21:30:24.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/10/BigData-7/">BigData(7)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Link-Analysis-Algorithms"><a href="#Link-Analysis-Algorithms" class="headerlink" title="Link Analysis Algorithms"></a>Link Analysis Algorithms</h2><p>There are three algorithms involved to compute the <strong>importance</strong> of nodes in the graph.</p>
<ul>
<li><code>Page Rank</code></li>
<li><code>Topic-Specific (Personalized) Page Rank</code></li>
<li><code>Web Spam Detection Algorithms</code></li>
</ul>
<h2 id="Page-Rank"><a href="#Page-Rank" class="headerlink" title="Page Rank"></a>Page Rank</h2><p>In page rank, the higher the score, the more important a node is. There is one important property of this algorithm, <strong>a page is important if it is pointed by other important pages.</strong></p>
<img src="/2020/11/10/BigData-7/flow_equation.png" class="" title="flow_equation">

<p>A flow equation is used to describe the rank.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">For node a, we can see that there are 2 outgoing links, each of the link will have a&#x2F;2.</span><br><span class="line">Similarly, node y has two outgoings, so each link is y&#x2F;2.</span><br><span class="line">For node m, only one outgoing, thus, link has m.</span><br><span class="line"></span><br><span class="line">To get the rank of y, sum up all incoming links:</span><br><span class="line">y&#x2F;2 + a&#x2F;2</span><br><span class="line"></span><br><span class="line">To get the rank of a, sum up all incoming links:</span><br><span class="line">y&#x2F;2 + m</span><br><span class="line"></span><br><span class="line">To get the rank of m, sum up all incoming links:</span><br><span class="line">a&#x2F;2</span><br></pre></td></tr></table></figure>
<p>Thus, the flow equation is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ry &#x3D; ry&#x2F;2 + ra&#x2F;2</span><br><span class="line">ra &#x3D; ry&#x2F;2 + rm</span><br><span class="line">rm &#x3D; ra&#x2F;2</span><br></pre></td></tr></table></figure>
<p>As there are three unknowns, three equations without constants, we add one more constraint to force the uniqueness:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ry + ra + rm &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>With this, we are able to calculate the page rank. However, the calculation will be very heavy when there is a large number of nodes.</p>
<h2 id="Power-iteration"><a href="#Power-iteration" class="headerlink" title="Power iteration"></a>Power iteration</h2><p>There are two parts involved in <code>power iteration</code>:</p>
<ul>
<li><code>Stochastic adjacency matrix M</code></li>
<li><code>Eigenvector</code></li>
</ul>
<p>From above, we can build a stochastic adjacency matrix M:</p>


<p>Apply the power iteration:</p>


<h2 id="Random-Teleports"><a href="#Random-Teleports" class="headerlink" title="Random Teleports"></a>Random Teleports</h2><ol>
<li><p><strong>Dead Ends</strong>. The result might not converge:<br>Node <code>A</code> points to Node <code>B</code> and Node B points to Node <code>A</code>, <code>A</code> &lt;—&gt; <code>B</code></p>
</li>
<li><p><strong>Spider traps</strong>. Importance information leaks out:<br>Node <code>A</code> points to Node <code>B</code>, <code>A</code> —&gt; <code>B</code></p>
</li>
</ol>
<p>To solve these, <code>Teleports</code> is introduced by Google. The solution is that in each ‘flow’, it has certain opportunity to jump to other nodes (not the linked one).</p>
<img src="/2020/11/10/BigData-7/illustration_random_teleport.png" class="" title="illustration_random_teleport">
<img src="/2020/11/10/BigData-7/illustration_random_teleport_calculation.png" class="" title="illustration_random_teleport_calculation">

<h2 id="Topic-Specific-PageRank"><a href="#Topic-Specific-PageRank" class="headerlink" title="Topic-Specific PageRank"></a>Topic-Specific PageRank</h2><p>The evaluation is not just conducted for the popularity but on the topic as well. To achieve this, the probability assigned for teleport is not consistent for all nodes. Instead, <strong>when a walker teleports, only a page in a set S which only includes pages are relevant to the topic will be picked.</strong></p>
<h2 id="SimRank"><a href="#SimRank" class="headerlink" title="SimRank"></a>SimRank</h2><blockquote>
<p>Effectively, SimRank is a measure that says “two objects are considered to be similar if they are referenced by similar objects.”</p>
</blockquote>
<h2 id="TrustRank"><a href="#TrustRank" class="headerlink" title="TrustRank"></a>TrustRank</h2><ul>
<li><code>Link Farms</code>: <code>Inaccessible pages</code>, <code>Accessible pages</code> and <code>Owned pages</code></li>
</ul>
<h2 id="HITS"><a href="#HITS" class="headerlink" title="HITS"></a>HITS</h2><ul>
<li><code>Hubs</code> and <code>Authorities</code></li>
</ul>
<p><strong>Hubs</strong><br>Quality as an expert. Total sum of votes for authorities pointed to.</p>
<p><strong>Authority</strong><br>Quality as a content. Total sum of votes coming from experts.</p>
<blockquote>
<p>Authorities are pages containing useful information like Newspaper home pages, Course home pages and Home pages of auto manufacturers</p>
</blockquote>
<blockquote>
<p>Hubs are pages that link to authorities like List of newspapers, Course bulletin and List of US auto manufacturers</p>
</blockquote>
<img src="/2020/11/10/BigData-7/HITS_flow.png" class="" title="HITS_flow">



<h2 id="Difference-between-PageRank-and-HITS"><a href="#Difference-between-PageRank-and-HITS" class="headerlink" title="Difference between PageRank and HITS"></a>Difference between PageRank and HITS</h2><ul>
<li>In the PageRank model, the value of the link depends on the <strong>links into u</strong></li>
<li>In the HITS model, it depends on the value of the other <strong>links out of u</strong></li>
</ul>
<h2 id="Pregel"><a href="#Pregel" class="headerlink" title="Pregel"></a>Pregel</h2><p>Pregel is serving as a computational model. There are four basic elements in Pregel model:</p>
<ul>
<li><code>Vertex</code>: In Pregel, each node(vertex) has an unique ID</li>
<li><code>Edge</code>: In Pregel, each edge can be assigned with a property</li>
<li><code>Message</code>: Message is the core design in Pregel. Message is used to indicate the status of a vertex.</li>
<li><code>Superstep</code>: One superstep is an iteration of computation happens in the Pregel.</li>
</ul>
<p>In Pregel, for each vertex at each superstep, it will receive a set of messages from previous superstep. The vertex will process all the messages then emit these messages to other vertex.</p>
<br/>
<br/>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://cloud.tencent.com/developer/news/148367" target="_blank" rel="noopener">Pregel总结</a></li>
<li><a href="https://io-meter.com/2018/03/23/pregel-in-graphs/" target="_blank" rel="noopener">图解图算法 Pregel: 模型简介与实战案例</a></li>
<li><a href="https://cshihong.github.io/2018/05/30/Pregel%EF%BC%88%E5%9B%BE%E8%AE%A1%E7%AE%97%EF%BC%89%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Pregel（图计算）技术原理</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/10/BigData-7/" data-id="ckhsvnfx9000rzxr1c4bqah6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/10/BigData-4/" class="article-date">
  <time datetime="2020-11-10T13:26:40.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/10/BigData-4/">BigData(4)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Locality-Sensitive-Hashing"><a href="#Locality-Sensitive-Hashing" class="headerlink" title="Locality Sensitive Hashing"></a>Locality Sensitive Hashing</h2><ul>
<li><code>Jaccard distance/similarity</code></li>
<li><code>Shingling</code></li>
<li><code>Min-hashing</code></li>
<li><code>Locality Sensitive Hashing(LSH)</code></li>
</ul>
<p><strong>Jaccard Distance/Similarity</strong></p>
<p>We use Jaccard similarity to define the “distance” betweem two elements.</p>
<p>If we have two <strong>sets</strong>, [1,2,3,4,5,6] and [3,4,6,9,10], there are 3 elements are in intersection: [3,4,6] and there are 8 elements in the union: [1,2,3,4,5,6,9,10], thus, we have:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jaccard similarity &#x3D; 3&#x2F;8</span><br><span class="line">Jaccard distance &#x3D; 1 - Jaccard similarity &#x3D; 1 - 3&#x2F;8 &#x3D; 5&#x2F;8</span><br></pre></td></tr></table></figure>

<p><strong>Shingling</strong></p>
<p>Shingling is to convert document into sets.</p>
<blockquote>
<p>A k-shingle (or k-gram) for a document is a sequence of k tokens that appears in the doc.</p>
</blockquote>
<p><strong>The order does matter here and the token can be a character or word or even a feature.</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">&#123;Hello world&#125;</span><br><span class="line">k &#x3D; 3 characters, we will have &#123;Hel, ell, llo, lo_, o_w, _wo, wor, rld&#125;</span><br><span class="line">k &#x3D; 1 word, we will have &#123;Hello, world&#125;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">&#123;abcab&#125;</span><br><span class="line">k &#x3D; 2, we will have &#123;ab, bc, ca, ab&#125; &#x3D;&gt; remove duplicates &#x3D;&gt; &#123;ab, bc, ca&#125;</span><br><span class="line">Thus, the final result is &#123;ab, bc, ca&#125;</span><br></pre></td></tr></table></figure>

<p>Examples on how the to find the similarity between documents.</p>



<p>From the diagram, we can see</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intersection &#x3D; 3</span><br><span class="line">union &#x3D; 6</span><br><span class="line">Jaccard similarity &#x3D; 3&#x2F;6</span><br><span class="line">Jaccard distance &#x3D; 1 - 3&#x2F;6 &#x3D; 3&#x2F;6</span><br></pre></td></tr></table></figure>

<p>However, using this method, the computation will be very heavy. </p>
<p><strong>Min-hashing</strong></p>
<p>When a document is very big, it result in a huge amount of shingles. Thus, hashing can be used to compress shingles. </p>
<blockquote>
<p>Minshaing converts large sets to short signatures, while preserving similarity</p>
</blockquote>
<p><strong>Note: min-hashing is specifically for Jaccard similarity</strong></p>
<p>The sample of how min-hashing works is shown below.</p>


<p>The signature matrix taken from the example is the [1,2,2,1]</p>
<p>After calculate multiple rounds of permutations independently, as shown below.</p>


<p>There are 3 signature matrix:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2,1,2,1</span><br><span class="line">2,1,4,1</span><br><span class="line">1,2,1,2</span><br></pre></td></tr></table></figure>

<p>The similarity calculation is</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Column 1 &amp; Column 3:</span><br><span class="line">Column 1 has (1,2)</span><br><span class="line">Column 3 has (1,2,4)</span><br><span class="line">Union: 3 as (1,2,4)</span><br><span class="line">Intersection: 2 as (1,2)</span><br><span class="line">Similarity &#x3D; 2&#x2F;3</span><br><span class="line">Distance &#x3D; 1 - 2&#x2F;3 &#x3D; 1&#x2F;3</span><br><span class="line">(2,4) are the only 1 different. So similarity &#x3D; 1 &#x2F; 3 &#x3D; 0.67</span><br></pre></td></tr></table></figure>

<p><strong>Locality Sensitive Hashing(LSH)</strong></p>
<p>Find a documents with Jaccard similarity at least s.</p>
<h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/10/BigData-4/" data-id="ckhsvnfx5000lzxr19n91bcm8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/10/BigData-6/" class="article-date">
  <time datetime="2020-11-10T13:24:56.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/10/BigData-6/">BigData(6)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Spark generalizes the MapReduce to provide the following features:</p>
<ul>
<li><code>High performance</code></li>
<li><code>Better programmability</code></li>
<li><code>A unified engine</code></li>
</ul>
<h2 id="RDD-Resilient-Distributed-Datasets"><a href="#RDD-Resilient-Distributed-Datasets" class="headerlink" title="RDD (Resilient Distributed Datasets)"></a>RDD (Resilient Distributed Datasets)</h2><p>RDD is the core abstraction. </p>
<blockquote>
<p>Collections of objects spread across a cluster, stored in RAM or on Disk. Built through parallel transformations and automatically rebuilt on failure</p>
</blockquote>
<p>There are two types of RDD:</p>
<ul>
<li><code>Parallelized collections</code>: take an existing single-node collection and parallel it</li>
<li><code>Hadoop datasets</code>: files on HDFS or other compatible storage</li>
</ul>
<p>The operations on RDDs are not computed immediately. Instead, only certain actions will trigger the computation, for example, <code>count</code>, <code>saveAsTextFile</code>.</p>
<p>RDDs track lineage information to reconstruct lost partitions.</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>Spark SQL is a Spark module for structured data processing. There are several ways to interact with Spark SQL including SQL and the Dataset API and with the extra information to perform extra optimizations, and a DataFrame is a Dataset organized into named columns. The image below shows the general idea.</p>
<img src="/2020/11/10/BigData-6/SparkSQL.png" class="" title="SparkSQL">

<p>DataFrames hold a row with schema information and provides a relational operations regarding the schema.</p>
<h2 id="Directions-for-Spark"><a href="#Directions-for-Spark" class="headerlink" title="Directions for Spark"></a>Directions for Spark</h2><ul>
<li><code>Multi-core scalability</code></li>
<li><code>Continuous (streaming) applications</code></li>
</ul>
<h2 id="Challenges-faced-for-numerical-computation-over-big-data"><a href="#Challenges-faced-for-numerical-computation-over-big-data" class="headerlink" title="Challenges faced for numerical computation over big data"></a>Challenges faced for numerical computation over big data</h2><ul>
<li><code>Correctness</code></li>
<li><code>Performance</code>: Cache RDDs to avoid I/O and avoid unnecessary computation</li>
<li><code>Trade-off between accuracy and performance</code></li>
</ul>
<h2 id="Spark-libraries"><a href="#Spark-libraries" class="headerlink" title="Spark libraries"></a>Spark libraries</h2><p>There are many libraries in Spark to support common algorithms, like GraphX, MLlib, etc.</p>
<ul>
<li><code>GraphX</code>: A general graph processing library. It builds the graph using RDDs of nodes and edges.</li>
<li><code>Spark streaming</code>: It will split the live stream into different chunks and each chunk of data will be treated as RDDs and the processed results will be returned in batches.</li>
<li><code>Spark SQL</code>: Enables to save and query the structured data in Spark.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;Example&quot;,</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Mike&quot;,</span><br><span class="line">    &quot;id:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">To query from Json, we can have:</span><br><span class="line">c.sql(&quot;select user.name from tweets&quot;)</span><br></pre></td></tr></table></figure></li>
<li><code>MLlib</code>: Support different machine learning algorithms</li>
</ul>
<br/>
<br/>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html" target="_blank" rel="noopener">Spark SQL, DataFrame 和 Dataset 编程指南</a></li>
<li><a href="https://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank" rel="noopener">Spark SQL, DataFrames and Datasets Guide</a></li>
<li><a href="https://blog.csdn.net/zg_hover/article/details/73159212" target="_blank" rel="noopener">spark2.0原理分析–RDD血缘（RDD Lineage）</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/10/BigData-6/" data-id="ckhsvnfx8000qzxr18gce0r2a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigData-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/09/BigData-5/" class="article-date">
  <time datetime="2020-11-09T20:35:18.000Z" itemprop="datePublished">2020-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/09/BigData-5/">BigData(5)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is revision note for NUS master study of CS5425 Big Data Systems for Data Science.</p>
<h2 id="Hadoop-VS-Databases"><a href="#Hadoop-VS-Databases" class="headerlink" title="Hadoop VS Databases"></a>Hadoop VS Databases</h2><blockquote>
<p>Apache Hadoop is not a database storage or relational storage, its main competency is to process data in a distributed fashion. It does have a storage component called HDFS (Hadoop Distributed File System) which stoes files used for processing but HDFS does not qualify as a relational database, it is just a storage model.</p>
</blockquote>
<blockquote>
<p>There are components like Hive which can work on top of HDFS and which allows users to query the HDFS storage using SQL like queries using HiveQL but that is just SQL like queries and does not make HDFS or Apcahe Hadoop a database or relational database.</p>
</blockquote>
<p>Thus, Hadoop is not a database even though it has a storage system HDFS. But can Hadoop replace the existing database? The answer is uncertain.</p>
<p>Firstly, schema is supported by relational database. Schema has its own advantages like it defines the contract of data format and it decouples the logical from physical. Moreover, with schema, there is no need to parse the data to get related fields. </p>
<p>Secondly, column stores are good. Compared to the row stores, a column store has advantages like:</p>
<ul>
<li><code>Read efficiency</code>: Usually only few columns will be selected for a query</li>
<li><code>Better compression</code>: Data under same column will have the same data type.</li>
<li><code>Vectorized processing</code><blockquote>
<p>SIMD(Single Instruction Multiple Data)即单指令流多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。简单来说就是一个指令能够同时处理多个数据。</p>
</blockquote>
</li>
<li><code>Opportunities to operate directly on compressed data</code></li>
</ul>
<h2 id="HadoopDB"><a href="#HadoopDB" class="headerlink" title="HadoopDB"></a>HadoopDB</h2><p>HadoopDB is an idea where co-locate a RDBMS on every slave node.</p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><ul>
<li><code>Thrift</code>: To support schema on Hadoop</li>
<li><code>HDFS Block</code>: In each HDFS block, RCFile organizes the records with the basic unit of a row group. </li>
<li><code>User Defined Functions (UDF)</code>: Provide index</li>
</ul>
<h2 id="YARN-Yet-Another-Resource-Negotiator"><a href="#YARN-Yet-Another-Resource-Negotiator" class="headerlink" title="YARN - Yet Another Resource Negotiator"></a>YARN - Yet Another Resource Negotiator</h2><p>Yarn provides resource management and a central platform to deliver consistent operations, security and data governance tools across Hadoop clusters.</p>
<blockquote>
<p>By separating resource management functions from the programming model, YARN delegates many scheduling-related functions to per-job components.</p>
</blockquote>
<h2 id="Dryad-Graph-Operators"><a href="#Dryad-Graph-Operators" class="headerlink" title="Dryad - Graph Operators"></a>Dryad - Graph Operators</h2><p>Dryad is a general-purpose distributed execution engine for coarse-grain data-parallel applications. </p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>There are two problems with MapReduce:</p>
<ul>
<li>Programming language is Java</li>
<li>Each MapReduce job will be written into disk, the shuffle is a bottleneck</li>
</ul>
<p>Spark is a solution that extends the MapReduce.</p>
<h2 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h2><p>There are three roles in the Presto query execution:</p>
<ul>
<li><code>Coordinator</code>: analyze and schedule</li>
<li><code>Discovery</code>: heartbeat and role managements</li>
<li><code>Worker</code>: execute</li>
</ul>
<p>The query sent by the presto-cli is a HTTP POST request, and it will be sent to the coordinator. In side the coordinator, the query will be parsed to an Abstract Syntax Tree (AST), then analyzer will convert it to the logical query plan &amp; distributed query plan, the optimizer will make it as optimized query plan, and sent to execution planner.</p>
<blockquote>
<p>抽象语法树树，描述的最原始的用户需求。抽象语法树描述的信息，执行效率上不是最优，执行操作也过于复杂。需要把抽象语法树转化成执行计划。执行计划分成两类，一类是逻辑执行计划，一类是物理执行计划。逻辑执行计划，以树状结构来描述执行，每个节点是最简单的操作。物理执行计划，根据逻辑执行计划生成字节码，交由驱动执行。</p>
</blockquote>
<br/>
<br/>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://examples.javacodegeeks.com/enterprise-java/apache-hadoop/is-hadoop-a-database/" target="_blank" rel="noopener">Is Hadoop a database</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/55108455" target="_blank" rel="noopener">深入浅出Hadoop YARN</a></li>
<li><a href="https://chu888chu888.gitbooks.io/hadoopstudy/content/Content/8/chapter8.html" target="_blank" rel="noopener">第八章 Hive的安装与数据导入导出</a></li>
<li><a href="https://chu888chu888.gitbooks.io/hadoopstudy/content/Content/3/chapter0301.html" target="_blank" rel="noopener">Hadoop的一些基本概念</a></li>
<li><a href="https://tech.meituan.com/2014/06/16/presto.html" target="_blank" rel="noopener">Presto实现原理和美团的使用实践</a></li>
<li><a href="https://blog.csdn.net/sjtuyunlei/article/details/79382979" target="_blank" rel="noopener">深入理解Presto(2) ：Presto查询执行过程</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shimingwu.github.io/2020/11/09/BigData-5/" data-id="ckhsvnfx7000nzxr1etvghwix" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Big-Data/" rel="tag">Big Data</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-Database/" rel="tag">Distributed Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueJs/" rel="tag">VueJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E6%80%A7/" rel="tag">安全性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 12.5px;">Algorithm</a> <a href="/tags/Big-Data/" style="font-size: 20px;">Big Data</a> <a href="/tags/Data-Structure/" style="font-size: 17.5px;">Data Structure</a> <a href="/tags/Distributed-Database/" style="font-size: 17.5px;">Distributed Database</a> <a href="/tags/LeetCode/" style="font-size: 12.5px;">LeetCode</a> <a href="/tags/VueJs/" style="font-size: 10px;">VueJs</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">协议</a> <a href="/tags/%E5%AE%89%E5%85%A8%E6%80%A7/" style="font-size: 12.5px;">安全性</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/22/Distributed-Database-System-5/">Distributed Database System (5)</a>
          </li>
        
          <li>
            <a href="/2020/11/22/Distributed-Database-System-4/">Distributed Database System (4)</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Distributed-Database-System-3/">Distributed Database System (3)</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Distributed-Database-System-2/">Distributed Database System (2)</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Distributed-Database-System-1/">Distributed Database System (1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Shiming Wu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>